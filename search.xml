<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java differenves by Version</title>
    <url>/2020/04/01/2020-04-01-java-differences-by-Version/</url>
    <content><![CDATA[<span id="more"></span>

<h1>Java 버전별 차이점</h1>

<h4>201901694 이동빈</h4>



<h2 id="2000년도"><a href="#2000년도" class="headerlink" title="~2000년도"></a>~2000년도</h2><hr>
<h3 id="JDK-1-0a"><a href="#JDK-1-0a" class="headerlink" title="JDK 1.0a"></a>JDK 1.0a</h3><ul>
<li>발표 : 1994년도</li>
</ul>
<hr>
<h3 id="JDK-1-0a2"><a href="#JDK-1-0a2" class="headerlink" title="JDK 1.0a2"></a>JDK 1.0a2</h3><ul>
<li>발표 : 1995년 5월 23일</li>
<li>특징</li>
</ul>
<p><strong>언어 자체가 정식으로 발표된 날이다.</strong></p>
<hr>
<h3 id="JDK-1-0"><a href="#JDK-1-0" class="headerlink" title="JDK 1.0"></a>JDK 1.0</h3><ul>
<li><p>발표 : 1996년 1월 23일</p>
</li>
<li><p>특징</p>
<p>발표 이전에 불렸던 이름은 <code>Oak</code>였으며, 안정화 작업을 거친 1.0.2 버전에서 <code>Java</code>로 이름이 바뀌었다.</p>
</li>
</ul>
<hr>
<h3 id="JDK-1-1"><a href="#JDK-1-1" class="headerlink" title="JDK 1.1"></a>JDK 1.1</h3><ul>
<li>발표 : 1997년 2월 19일</li>
<li>추가된 기능<ul>
<li><code>inner class</code></li>
<li><code>JavaBeans</code></li>
<li><code>RMI</code></li>
<li><code>reflection</code></li>
<li>유니코드 지원</li>
<li><code>국제화(Internationalization)</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="J2SE-1-2"><a href="#J2SE-1-2" class="headerlink" title="J2SE 1.2"></a>J2SE 1.2</h3><ul>
<li><p>발표 : 1998년 12월 8일</p>
</li>
<li><p>지원 종료 : 2003년 11월</p>
</li>
<li><p>추가된 기능</p>
<ul>
<li>새로운 <code>GUI</code></li>
<li><code> JIT</code></li>
<li><code>CORBA</code></li>
<li><code>strictfp</code>, <code>Swing GUI</code>, <code>JIT</code>, <code>Java Applet</code>을 구동하는 웹 브라우저 플러그인</li>
<li><code>Collections</code></li>
</ul>
<br />
</li>
<li><p>기타 특징</p>
<p>굵직한 기능들이 추가되면서 2 부터 약칭을 <code>J2SE(Java 2 Standard Edition)</code> 로 표기하기 시작했으며, 이 표기는 5 까지 사용된다. 1999년에 업데이트를 통해 <code>HotSpot JVM</code>이 첫 선을 보인다.</p>
</li>
</ul>
<hr>
<h2 id="2000-2010년도"><a href="#2000-2010년도" class="headerlink" title="2000~2010년도"></a>2000~2010년도</h2><hr>
<h3 id="J2SE-1-3"><a href="#J2SE-1-3" class="headerlink" title="J2SE 1.3"></a>J2SE 1.3</h3><ul>
<li><p>발표 : 2000년 3월 8일</p>
</li>
<li><p>지원 종료 : 2006년 11월</p>
</li>
<li><p>추가된 기능</p>
<ul>
<li><code>HotSpot JVM</code></li>
<li><code>JNDI</code></li>
<li><code>JPDA</code></li>
<li><code>JavaSound</code></li>
</ul>
<br />
</li>
<li><p>기타 특징</p>
<p> <code>RMI</code>가 <code>CORBA</code>를 지원하도록 변경되었다.</p>
</li>
</ul>
<hr>
<h3 id="J2SE-1-4"><a href="#J2SE-1-4" class="headerlink" title="J2SE 1.4"></a>J2SE 1.4</h3><ul>
<li>발표 : 2002년 2월 6일</li>
<li>지원 종료 : 2008년 10월 <em>(2013년 2월까지 연장 지원)</em></li>
<li>추가된 기능<ul>
<li><code>assert</code>문</li>
<li>정규표현식</li>
<li><code>IPv6</code></li>
<li><code>Non-Blocking IO</code></li>
<li><code>XML API</code></li>
<li><code>JCE</code></li>
<li><code>JSSE</code></li>
<li><code>JAAS</code></li>
<li><code>Java Web Start</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="J2SE-5"><a href="#J2SE-5" class="headerlink" title="J2SE 5"></a>J2SE 5</h3><ul>
<li><p>발표 : 2004년 9월 30일</p>
</li>
<li><p>지원 종료 : 2009년 9월 <em>(2015년 5월까지 연장 지원)</em> </p>
</li>
<li><p>추가된 기능</p>
<ul>
<li><code>Generics</code></li>
<li><code>Annotation</code></li>
<li><code>Auto Boxing/Unboxing</code></li>
<li><code>Enumeration</code></li>
<li>가변 길이 파라미터</li>
<li><code>Static Import</code></li>
<li>새로운 <code>Concurrency API</code></li>
<li><code>java.util.Scanner</code> <em>(이전보다 편하게 표준 입력 사용 가능)</em></li>
<li><code>Windows 9x</code> &#x2F; <code>Windows NT 4.0</code> <em>(~&#96;J2SE 5.0&#96;)</em></li>
</ul>
<br />
</li>
<li><p>기타 특징</p>
<p><strong>이 때부터 버젼 중 앞의 1을 빼버리고 표기하기 시작했다.</strong> 그러나 내부적으로는 여전히 1.5, 1.6, 1.7 등으로 데이터가 들어있다.</p>
</li>
</ul>
<hr>
<h3 id="Java-SE-6"><a href="#Java-SE-6" class="headerlink" title="Java SE 6"></a>Java SE 6</h3><ul>
<li><p>발표 : 2006년 12월 11일</p>
</li>
<li><p>지원 종료 : 2013년 2월 <em>(2018년 12월까지 연장 지원)</em></p>
</li>
<li><p>추가된 기능</p>
<ul>
<li><code>Scripting Language Support</code></li>
<li><code>JDBC 4.0</code></li>
<li><code>Java Compiler API</code></li>
<li><code>Pluggable Annotation</code></li>
</ul>
<br />
</li>
<li><p>기타 특징</p>
<p><strong>이 때부터 표기가 <code>J2SE</code>에서 <code>Java SE</code>로 바뀌었다.</strong>  스크립팅 언어 지원과 함께 <code>Rhino JavaScript</code> 엔진이 기본으로 탑재되었다.</p>
</li>
</ul>
<hr>
<h2 id="2010년도-현재"><a href="#2010년도-현재" class="headerlink" title="2010년도~ 현재"></a>2010년도~ 현재</h2><hr>
<h3 id="Java-SE-7"><a href="#Java-SE-7" class="headerlink" title="Java SE 7"></a>Java SE 7</h3><ul>
<li>발표 : 2011년 7월 7일</li>
<li>지원 종료 : 2015년 4월 <em>(2022년 7월까지 연장 지원 예정)</em></li>
<li>추가된 기능<ul>
<li><code>Dynamic Language</code> 지원</li>
<li><code>switch</code>문에서 <code>String</code> 사용</li>
<li><code>try</code>문에서 자동 자원 관리</li>
<li><code>Diamond Operator &lt;&gt;</code></li>
<li>이진수 literal, 숫자 literal에 <code>_</code> 지원</li>
<li>새로운 <code>Concurrency API</code></li>
<li>새로운 <code>File NIO library</code></li>
<li><code>Elliptic Curve Cryptography</code></li>
<li><code>Java2D</code>를 위한 <code>XRender</code>, <code>Upstream</code>, <code>Java Deployment Ruleset</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="Java-SE-8"><a href="#Java-SE-8" class="headerlink" title="Java SE 8"></a>Java SE 8</h3><ul>
<li><p>발표 : 2014년 3월 18일</p>
</li>
<li><p>지원 종료 : 2019년 1월 <em>(2023년 9월까지 연장 지원 예정)</em></p>
</li>
<li><p>추가된 기능</p>
<ul>
<li><code>Unsigned Integer</code> 계산</li>
<li><code>Lambda Expression</code>, <code>Rhino</code> 대신 <code>Nashorn JavaScript</code> 엔진 탑재</li>
<li><code>Annotation on Java Types</code></li>
<li><code>Repeating Annotation</code></li>
<li>새로운 날짜와 시간 API <em>(사실상 JodaTime이라고 보면 된다)</em></li>
<li><code>Static Link JNI Library</code></li>
<li><code>Interface Default Method</code></li>
<li><code>PermGen</code> 영역 삭제</li>
<li><code>Stream API</code></li>
</ul>
<br />
</li>
<li><p>기타 특징</p>
<p>본래 일반 지원은 2017년 9월 종료 예정이었으나 <code>Java 9</code> 발표의 지연 때문에 2018년 9월로 연장되었다가, 이후 라이선스 이관 문제로 인해 2019년 1월로 다시 연장되었다.</p>
<p><strong>32비트를 지원하는 마지막 공식 Java 버전으로, 이후 버전의 32비트 지원은 오직 서드파티를 통해서만 지원된다.</strong></p>
</li>
</ul>
<hr>
<h3 id="Java-SE-9"><a href="#Java-SE-9" class="headerlink" title="Java SE 9"></a>Java SE 9</h3><ul>
<li><p>발표 : 2017년 9월 21일</p>
</li>
<li><p>지원 종료 : 2018년 3월</p>
</li>
<li><p>추가된 기능</p>
<ul>
<li><p><code>JShell</code> <em>(Java를 인터프리터 언어 셸처럼 사용할 수 있음)</em></p>
</li>
<li><p><code>Ahead-Of-Time Compilation</code> <em>( 실험 기능 &#x2F; Java 바이트코드를 기계어로 미리 번역)</em></p>
</li>
<li><p><code>구조적 불변 컬렉션</code>, <code>통합 로깅</code>,  <code>HTTP/2</code>, <code>private 인터페이스 메소드</code>, <code>HTML5 Javadoc</code> 지원</p>
</li>
<li><p>.properties 파일에 <code>UTF-8</code> 지원</p>
</li>
<li><p><code>Project Jigsaw</code> 기반으로 런타임 모듈화</p>
<ul>
<li><code>AWT</code>나 <code>Swing </code> 같은 불필요한 라이브러리를 끌어쓸 필요도 없이, 최상위 모듈인 <code>Base</code>만 사용해도 된다.</li>
<li>특정 프로그램에 최적화된 최소 런타임을 제작할 수 있게 되면서 패키징 역시 간편해졌다</li>
</ul>
<br /></li>
</ul>
</li>
<li><p>삭제된 기능</p>
<ul>
<li><code>Java Applet</code></li>
</ul>
<br />
</li>
<li><p>기타 특징</p>
<p> Deprecated 표시에는 해당 버전과 제거 예정 여부를 표시할 수 있게 되었다.</p>
<p>새로 적용된 버저닝 정책에 따라 이 버전부터는 더 이상 1.x 버전으로 내놓지 않고, 대신 <strong>9.0</strong>으로 급속한 판올림이 일어났다. 또한 제거 예정인 Deprecated API는 <strong>다음 버전인 Java SE 10부터 완전 삭제 예정</strong>이므로 해당 API를 쓰는 프로그램은 더 이상 이후의 버전에서 컴파일조차 불가능하게 된다. 그리고<code> Java SE 9</code>부터는 6개월마다 새로운 버전이 업데이트된다.</p>
<p>본래는 2016년 발표 예정이었으나 2번이나 연기되어 2017년 7월 27일 발표 예정, 그나마도 한번 더 연기되어 9월 21일에 발표되었다. 가장 큰 원인은 역시 <code>Project Jigsaw</code>의 개발 난이도였다. 런타임의 모듈화는 하위 호환성을 어느 정도 포기하고 성능을 추구한 것이기에 아직 현장에서는 <code>Java 9</code>로 넘어가는 것을 꺼리는 분위기다.</p>
<p><strong>이 버전부터 64비트 버전만 출시되었으며, 32비트 버전은 더 이상 공식적으로 나오지 않는다.</strong></p>
</li>
</ul>
<hr>
<h3 id="Java-SE-10"><a href="#Java-SE-10" class="headerlink" title="Java SE 10"></a>Java SE 10</h3><ul>
<li><p>발표 : 2018년 3월 20일</p>
</li>
<li><p>지원 종료 : 2018년 9월</p>
</li>
<li><p>추가된 기능</p>
<ul>
<li><code>var 키워드</code>를 이용한 지역 변수 타입 추론</li>
<li>병렬 garbage collection</li>
<li>개별 쓰레드로 분리된 <code>Stop-The-World</code></li>
<li><code>루트 CA 목록</code></li>
<li>Java 기반의 <code>JIT 컴파일러</code> <em>(실험 기능)</em></li>
</ul>
<br />
</li>
<li><p>기타 특징</p>
<p> JDK의 레포지토리가 하나로 통합되었으며, JVM 힙 영역을 시스템 메모리가 아닌 다른 종류의 메모리에도 할당할 수 있게 되었다. 이전 버전에서 Deprecated 처리된 API는 <code>Java SE 10</code>에서 모두 삭제되었다.</p>
</li>
</ul>
<hr>
<h3 id="Java-SE-11"><a href="#Java-SE-11" class="headerlink" title="Java SE 11"></a>Java SE 11</h3><ul>
<li><p>발표 : 2018년 9월 25일</p>
</li>
<li><p>지원 종료 : 2023년 9월 <em>(2026년 9월까지 연장 지원 예정)</em></p>
</li>
<li><p>추가된 기능</p>
<ul>
<li>lambda parameter에 대한 지역 변수 문법</li>
<li>epsilon garbage collector</li>
<li>HTTP 클라이언트 표준화 기능</li>
</ul>
<br />
</li>
<li><p>기타 특징</p>
<p>이클립스 재단으로 넘어간 <code>Java EE</code>가 JDK에서 삭제되고, <code>JavaFX</code>도 JDK에서 분리되어 별도의 모듈로 제공된다.  <code>Gloun</code>이라는 업체가 <code>JavaFX</code>를 유지보수 중이므로 <span class="exturl" data-url="aHR0cHM6Ly9nbHVvbmhxLmNvbS9wcm9kdWN0cy9qYXZhZngv">이곳<i class="fa fa-external-link-alt"></i></span>에서 다운로드받으면 된다.</p>
</li>
</ul>
<p> Java SE 11부터 Oracle JDK의 독점 기능이 오픈 소스 버전인 OpenJDK에 이식된다. 이는 다시 말해 Oracle JDK와 OpenJDK가 완전히 <strong>동일</strong>해진다는 뜻이다. Oracle JDK는 Java SE 11부터 LTS(장기 지원) 버전으로 3년마다 출시되는데, 출시 후 5년 동안 오라클의 기술 지원이 제공되고 최대 3년까지 지원 기간을 연장할 수 있다. Oracle JDK는 이제 3년에 한 번 출시되니 Java의 실질적인 버전 업을 담당하는 것은 OpenJDK가 된 셈이다. OpenJDK는 기업들을 위한 기술 지원은 없고, 새로운 버전이 나오면 이전 버전에 대한 마이너 업데이트와 보안 업데이트는 중단된다.</p>
<p>그리고 Java 11과 함께 발표된 또 다른 소식은 바로 <strong>Oracle JDK가 구독형 유료 모델로 전환된다는 점</strong>이다. 2019년 1월부터 오라클이 제공하는 모든 <code>Oracle JDK</code>는 유료화되며, 구독권을 구입하지 않으면 <code>Oracle JDK</code>에 접근 자체가 금지된다. 기존의 일반&#x2F;연장 지원 서비스는 구독권에 포함되므로 별도의 서비스로는 제공되지 않는다. <strong>개인 사용자는 2021년 1월부터 비용을 지불해야 한다.</strong> 이 때문에 많은 기업들이 <code>Oracle JDK</code>에서 발을 빼고 있으며, <code>OpenJDK</code>를 기반으로 한 다른 <code>서드파티 JDK</code>가 대안으로 떠오르고 있다. 대표적인 예로 <code>Azul Systems</code>에서 개발한 <code>Zulu JDK</code>가 있는데, <code>Zulu JDK</code>는 오라클의 <code>TCK(Technology Certification Kit)</code> 인증을 받은 구현체이다. 개인과 기업 모두 무료로 사용할 수 있고, 기술 지원에 한해서만 유료 서비스가 제공된다. 또 다른 대안으로는 <code>AdoptOpenJDK</code>가 있는데, <code>AdoptOpenJDK</code>는 <code>HotSpot VM</code> 대신 <code>Eclipse OpenJ9</code>을 탑재한 버전도 같이 제공하고 있다. 다만 아직 TCK 인증을 받지 않았기에 주의가 필요하다.</p>
<hr>
<h3 id="Java-SE-12"><a href="#Java-SE-12" class="headerlink" title="Java SE 12"></a>Java SE 12</h3><ul>
<li><p>발표 : 2019년 3월 19일</p>
</li>
<li><p>추가된 기능</p>
<ul>
<li>garbage collector 개선</li>
<li><code>micro benchmarking</code> 툴</li>
</ul>
<br />
</li>
<li><p>기타 특징</p>
<p>문법적으로 Switch문을 확장했다.</p>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">switch</span> <span class="token punctuation">(</span>day<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">case</span> <span class="token constant">MONDAY</span><span class="token operator">:</span>
    <span class="token keyword">case</span> <span class="token constant">FRIDAY</span><span class="token operator">:</span>
    <span class="token keyword">case</span> <span class="token constant">SUNDAY</span><span class="token operator">:</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token constant">TUESDAY</span><span class="token operator">:</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token constant">THURSDAY</span><span class="token operator">:</span>
    <span class="token keyword">case</span> <span class="token constant">SATURDAY</span><span class="token operator">:</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token constant">WEDNESDAY</span><span class="token operator">:</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>예전에는 이렇게 써야 했던 Switch문을 아래와 같은 형식으로도 쓸 수 있게 되었다.</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">switch</span> <span class="token punctuation">(</span>day<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">case</span> <span class="token constant">MONDAY</span><span class="token punctuation">,</span> <span class="token constant">FRIDAY</span><span class="token punctuation">,</span> <span class="token constant">SUNDAY</span> <span class="token operator">-></span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token constant">TUESDAY</span>                <span class="token operator">-></span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token constant">THURSDAY</span><span class="token punctuation">,</span> <span class="token constant">SATURDAY</span>     <span class="token operator">-></span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token constant">WEDNESDAY</span>              <span class="token operator">-></span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="Java-SE-13"><a href="#Java-SE-13" class="headerlink" title="Java SE 13"></a>Java SE 13</h3><ul>
<li><p>발표 : 2019년 9월 17일</p>
</li>
<li><p>특징</p>
<p>java 12에서의 스위치 개선을 이어 yield 라는 예약어가 추가되었다.</p>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">switch</span> <span class="token punctuation">(</span>day<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">case</span> <span class="token constant">MONDAY</span><span class="token punctuation">,</span> <span class="token constant">FRIDAY</span><span class="token punctuation">,</span> <span class="token constant">SUNDAY</span> <span class="token operator">-></span> <span class="token keyword">yield</span> <span class="token number">6</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token constant">TUESDAY</span>                <span class="token operator">-></span> <span class="token keyword">yield</span> <span class="token number">7</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token constant">THURSDAY</span><span class="token punctuation">,</span> <span class="token constant">SATURDAY</span>     <span class="token operator">-></span> <span class="token keyword">yield</span> <span class="token number">8</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token constant">WEDNESDAY</span>              <span class="token operator">-></span> <span class="token keyword">yield</span> <span class="token number">9</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="Java-SE-14"><a href="#Java-SE-14" class="headerlink" title="Java SE 14"></a>Java SE 14</h3><ul>
<li>발표 : 2020년 3월 18일</li>
</ul>
<hr>
<h2 id="앞으로-출시될-버전"><a href="#앞으로-출시될-버전" class="headerlink" title="앞으로 출시될 버전"></a>앞으로 출시될 버전</h2><hr>
<h3 id="Java-SE-15"><a href="#Java-SE-15" class="headerlink" title="Java SE 15"></a>Java SE 15</h3><ul>
<li>2020년 9월 공개 예정.</li>
</ul>
]]></content>
      <categories>
        <category>university</category>
      </categories>
      <tags>
        <tag>assignment</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces April Fools Day Contest 2020 review</title>
    <url>/2020/04/02/2020-04-02-Codeforces-April-Fools-Day-Contest-2020-review/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Codeforces-April-Fools-Day-Contest-2020-review"><a href="#Codeforces-April-Fools-Day-Contest-2020-review" class="headerlink" title="Codeforces April Fools Day Contest 2020 review"></a>Codeforces April Fools Day Contest 2020 review</h1><br />

<hr>
<br />

<h1 id="1-대회-소개"><a href="#1-대회-소개" class="headerlink" title="1. 대회 소개"></a>1. 대회 소개</h1><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzEzMzE=">대회 링크<i class="fa fa-external-link-alt"></i></span></p>
<p>![출처 : <span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzEzMzFd">https://codeforces.com/contest/1331]<i class="fa fa-external-link-alt"></i></span>(\images\2020-04-02\April Fools Day Contest 2020 introduction.JPG)</p>
<p>4&#x2F;1일에 진행된다.. 레이팅에 반영되지 않는다[^1].. 출제자와 유머 코드가 맞아야 한다..? 등의 내용입니다.</p>
<p><img src="/%5Cimages%5C2020-04-02%5Cparticipants.JPG" alt="출처 : https://codeforces.com/contests"></p>
<p>세계 각국에서 <strong>19470</strong> 분이나 참가하셨습니다.</p>
<br />

<hr>
<br />

<h1 id="2-목차"><a href="#2-목차" class="headerlink" title="2. 목차"></a>2. 목차</h1><p>![출처 : <span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzEzMzFd">https://codeforces.com/contest/1331]<i class="fa fa-external-link-alt"></i></span>(\images\2020-04-02\Problems list.JPG)</p>
<p>문제 목차입니다. <span style="color:green">초록색</span>은 제가 맞힌 문제, <span style="color:red">빨간색</span>은 제가 시도했지만 틀린 문제입니다.</p>
<p>총 8문제로 구성되었고, <span class="exturl" data-url="aHR0cHM6Ly93d3cudGltZWFuZGRhdGUuY29tL3dvcmxkY2xvY2svZml4ZWR0aW1lLmh0bWw/ZGF5PTEmbW9udGg9NCZ5ZWFyPTIwMjAmaG91cj0xNyZtaW49MzUmc2VjPTAmcDE9MTY2">우리나라 시계 기준 4&#x2F;1 밤 11시 35분<i class="fa fa-external-link-alt"></i></span>부터 2시간 동안 진행되었습니다. </p>
<br />

<hr>
<br />

<h1 id="3-문제-풀이"><a href="#3-문제-풀이" class="headerlink" title="3. 문제 풀이"></a>3. 문제 풀이</h1><p><img src="/%5Cimages%5C2020-04-02%5CA.JPG" alt="출처 : https://codeforces.com/contest/1331/problem/A"></p>
<p><a href="https://codeforces.com/contest/1331/problem/A"><code>A번 문제</code></a>입니다. 첫 문제부터 입출력 예제와 문제에 대한 설명이 하나도 없습니다…</p>
<br />

<h3 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h3><p>문제 이름이 <strong>“Is it rated?”</strong> 입니다.</p>
<p>대회 소개에서 <code>&quot;... and it will be unrated.&quot;</code> 라 했으므로, NO를 출력하면 되는 문제였습니다.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;
using namespace std;
 
int main()
&#123;
    printf(&quot;NO&quot;);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<br />

<hr>
<br />

<p><img src="/%5Cimages%5C2020-04-02%5CB.JPG" alt="출처 : https://codeforces.com/contest/1331/problem/B"></p>
<p><a href="https://codeforces.com/contest/1331/problem/B"><code>B번 문제</code></a>입니다. 문제 설명은 풀이와 아무 관련이 없는듯합니다..</p>
<br />

<h3 id="풀이-1"><a href="#풀이-1" class="headerlink" title="풀이"></a>풀이</h3><p><code>input</code>과 <code>output</code>간의 규칙을 보면, </p>
<table>
<thead>
<tr>
<th>Test case</th>
<th>input</th>
<th>output</th>
</tr>
</thead>
<tbody><tr>
<td>#1</td>
<td>35</td>
<td>57  (5*7)</td>
</tr>
<tr>
<td>#2</td>
<td>57</td>
<td>319  (3*19)</td>
</tr>
<tr>
<td>#3</td>
<td>391</td>
<td>1723  (17*23)</td>
</tr>
</tbody></table>
<p>output은 소수의 오름차순 곱으로 이루어져 있다는 것을 알 수 있습니다!</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;
using namespace std;
 
int prime[12] &#x3D; &#123; 2,3,5,7,11,13,17,19,23,29,31 &#125;;
 
int main(void)
&#123;
    int a;
    scanf(&quot;%d&quot;, &amp;a);
    for (int i &#x3D; 0; i &lt;&#x3D; 10; i++)
    &#123;
        if (a % prime[i] &#x3D;&#x3D; 0)
            while (a % prime[i] &#x3D;&#x3D; 0)
            &#123;
                printf(&quot;%d&quot;, prime[i]);
                a &#x2F;&#x3D; prime[i];
            &#125;
        if (a &#x3D;&#x3D; 1)
            break;
    &#125;
    if (a !&#x3D; 1)
        printf(&quot;%d&quot;, a);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<br />

<hr>
<br />

<p><img src="/%5Cimages%5C2020-04-02%5CC.JPG" alt="출처 : https://codeforces.com/contest/1331/problem/C"></p>
<p><a href="https://codeforces.com/contest/1331/problem/C"><code>C번 문제</code></a>입니다. 풀이를 생각해내는 데 한참 걸렸습니다.</p>
<p>문제 이름을 해석하면 “… 그리고 그들은 행복하게 살았답니다.” 정도인 것 같습니다.</p>
<p>동화의 마무리 멘트 같은 느낌이네요.</p>
<br />

<h3 id="풀이-2"><a href="#풀이-2" class="headerlink" title="풀이"></a>풀이</h3><p><strong>a의 범위가 0~63</strong> 인 것에 착안하여, <code>input</code>과 <code>output</code>을 <strong>6개의 2진수 비트</strong> 로 나타내면 다음과 같습니다.</p>
<table>
<thead>
<tr>
<th>Test case</th>
<th>input(binary)</th>
<th>output(binary)</th>
<th>비트 이동</th>
</tr>
</thead>
<tbody><tr>
<td>#1</td>
<td>000010</td>
<td>000010</td>
<td>2-&gt;2</td>
</tr>
<tr>
<td>#2</td>
<td>000101</td>
<td>011000</td>
<td>1-&gt;5, 3-&gt;4</td>
</tr>
<tr>
<td>#3</td>
<td>100011</td>
<td>110010</td>
<td>1-&gt;5, 2-&gt;2, 6-&gt;6</td>
</tr>
</tbody></table>
<p>표의 <code>비트 이동</code>과 같은 규칙으로 비트가 이동했음을 알 수 있습니다.</p>
<p>예시만으로는 4번째 비트와 5번째 비트가 어디로 이동하는지 알 수 없으므로, <del>운으로 찍었습니다.</del></p>
<blockquote>
<p> (더 정확한 풀이를 아시는 분은 <span class="exturl" data-url="bWFpbHRvOiYjMTAwOyYjMTExOyYjMTEwOyYjeDY3OyYjeDYyOyYjMTA1OyYjMTEwOyYjeDMxOyYjeDM5OyYjNTc7JiN4Mzk7JiM2NDsmI3g2OTsmI3g2ZTsmIzExNzsmIzQ2OyYjOTc7JiN4NjM7JiM0NjsmIzEwNzsmI3g3Mjs=">&#100;&#111;&#110;&#x67;&#x62;&#105;&#110;&#x31;&#x39;&#57;&#x39;&#64;&#x69;&#x6e;&#117;&#46;&#97;&#x63;&#46;&#107;&#x72;<i class="fa fa-external-link-alt"></i></span> 로 알려주세요!)</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;
using namespace std;
 
int main(void)
&#123;
    int a;
    scanf(&quot;%d&quot;, &amp;a);
    int b[6] &#x3D; &#123; 0 &#125;;
    for (int i &#x3D; 0; i &lt; 6; i++)
        if ((a &amp; (1 &lt;&lt; i)) !&#x3D; 0)
            b[i] &#x3D; 1;
    int ans &#x3D; 0;
    if (b[0])
        ans +&#x3D; 16;
    if (b[1])
        ans +&#x3D; 2;
    if (b[2])
        ans +&#x3D; 8;
    if (b[3])
        ans +&#x3D; 4;
    if (b[4])
        ans +&#x3D; 1;
    if (b[5])
        ans +&#x3D; 32;
    printf(&quot;%d&quot;, ans);
    
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<br />

<hr>
<br />

<p><img src="/%5Cimages%5C2020-04-02%5CD.JPG" alt="출처 : https://codeforces.com/contest/1331/problem/D"></p>
<p><a href="https://codeforces.com/contest/1331/problem/D"><code>D번 문제</code></a>입니다. 오른쪽 아래<code>Problem tags</code>에 <code>chinese remainder theorem</code>[^2]라고 나와있는데, 저게 왜 필요한지 잘 모르겠습니다. 만우절 디테일에 신경 쓴 듯합니다.</p>
<br />

<h3 id="풀이-3"><a href="#풀이-3" class="headerlink" title="풀이"></a>풀이</h3><p>A 뒤에 나오는 숫자를 2로 나눈 나머지를 출력하면 됩니다.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;
using namespace std;
 
int main(void)
&#123;
    int a;
    char c;
    scanf(&quot;%c&quot;, &amp;c);
    scanf(&quot;%d&quot;, &amp;a);
    printf(&quot;%d&quot;, a % 2 &#x3D;&#x3D; 0 ? 0 : 1);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<br />

<hr>
<br />

<p><strong>여기서부터는 제가 풀지 못한 문제들이라 짧게 리뷰하고 넘어가겠습니다.</strong></p>
<p><img src="/%5Cimages%5C2020-04-02%5CE1.JPG" alt="출처 : https://codeforces.com/contest/1331/problem/E"></p>
<p><img src="/%5Cimages%5C2020-04-02%5CE2.JPG" alt="출처 : https://codeforces.com/contest/1331/problem/E"></p>
<p><a href="https://codeforces.com/contest/1331/problem/E"><code>E번 문제</code></a>입니다. 푸는 데 상당히 많은 시간이 걸릴 것 같은 문제입니다.</p>
<br />

<h3 id="풀이-4"><a href="#풀이-4" class="headerlink" title="풀이"></a>풀이</h3><p><code>input</code>좌표가 그림 속 얼굴 안쪽이면 IN을, 바깥쪽이면 OUT을 출력하는 문제 같습니다.</p>
<p>저는 주어진 시간인 2시간 내에 풀지 못할 것 같아 넘겼습니다.  <strong><del>귀찮아서</del></strong></p>
<br />

<hr>
<br />

<p><img src="/%5Cimages%5C2020-04-02%5CF.JPG" alt="출처 : https://codeforces.com/contest/1331/problem/F"></p>
<p><a href="https://codeforces.com/contest/1331/problem/F"><code>F번 문제</code></a>입니다. 풀이가 너무 궁금하여 다른 분들의 코드를 참고했는데, 저는 대회 시간이 10시간이었더라도 못 풀었을 문제입니다. 풀이를 보시기 전에 한 번 고민해보세요!</p>
<br />

<h3 id="풀이-5"><a href="#풀이-5" class="headerlink" title="풀이"></a>풀이</h3><details><summary>풀이 보기</summary>주기율표의 원소기호만 사용하여 `input`의 단어를 만들 수 있으면 `YES`를, 아니면 `NO`를 출력하는 문제입니다.
예를 들어, GENIUS -> 'Ge(저마늄)' + 'N(질소)' + 'I(아이오딘)' + 'U(우라늄)' + 'S(황)'으로 표현이 가능하므로 'YES'입니다.</details>

<br />

<hr>
<br />

<p><a href="https://codeforces.com/contest/1331/problem/G"><code>G번 문제</code></a>, <a href="https://codeforces.com/contest/1331/problem/H"><code>H번 문제</code></a>는 코드를 참고해도 모르겠습니다..</p>
<p>특히 H번 문제는 <code>UnknownX</code>라는 언어로 제출 언어 제한이 걸려있습니다.</p>
<p>H번 문제의 풀이 자체는 <code>n</code>의 <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG91YmxlX2ZhY3RvcmlhbA==">double factorial<i class="fa fa-external-link-alt"></i></span>을 <code>mod</code>로 나눈 나머지를 구하라는 문제인데, C++ 코드를 그대로 제출하니 <span style="color:blue"><code>Compilation error</code></span>를 받았습니다.</p>
<p>제출했던 코드는 아래와 같습니다.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;
using namespace std;
 
int main(void)
&#123;
    int temp;
    scanf(&quot;%d&quot;, &amp;temp);
    int n &#x3D; temp &#x2F; 1000;
    int mod &#x3D; temp % 1000;
    int ans &#x3D; 1;
    for (int i &#x3D; n; i &gt; 0; i -&#x3D; 2)
        ans &#x3D; (ans * i) % mod;
    
    printf(&quot;%d&quot;, ans);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<br />

<hr>
<br />

<h1 id="4-결과"><a href="#4-결과" class="headerlink" title="4. 결과"></a>4. 결과</h1><p><img src="/%5Cimages%5C2020-04-02%5Cstanding.JPG" alt="출처 : https://codeforces.com/contest/1331/standings"></p>
<p>제 성적입니다.</p>
<ul>
<li><strong><span style="color:green">초록색 +</span></strong> 는 맞힌 문제, <strong><span style="color:green">+</span></strong> 뒤의 숫자는 틀린 횟수를 나타냅니다.</li>
<li><strong>틀린 횟수 당 10분의 패널티가 주어집니다.</strong></li>
<li><strong><span style="color:blue"><code>-2</code></span></strong> 는 2번 틀리고 풀지 못했음을 나타냅니다.</li>
<li><code>Tried</code>는 각 문제당 제출된 코드 수, <strong><span style="color:green"><code>Accepted</code></span></strong> 는 그중 맞힌 사람의 수를 나타냅니다.</li>
</ul>
<p><br /><br /><br /></p>
<p>혹시 코딩에 관심 있으신 분은 코드포스 대회에 참여해보시는 걸 추천합니다!</p>
<p>여기까지 후기였습니다. 긴 글 봐주셔서 감사합니다!</p>
<br />

<p>[^1]: Codeforces는 대회 성적을 반영한 rating시스템이 있습니다.<br>[^2]: [중국인의 나머지 정리]([<span class="exturl" data-url="aHR0cHM6Ly9uYW11Lndpa2kvdy8lRUMlQTQlOTElRUElQjUlQUQlRUMlOUQlQjglRUMlOUQlOTglMjAlRUIlODIlOTglRUIlQTglQjglRUMlQTclODAlMjAlRUMlQTAlOTUlRUIlQTYlQUNd">https://namu.wiki/w/%EC%A4%91%EA%B5%AD%EC%9D%B8%EC%9D%98%20%EB%82%98%EB%A8%B8%EC%A7%80%20%EC%A0%95%EB%A6%AC]<i class="fa fa-external-link-alt"></i></span>(<span class="exturl" data-url="aHR0cHM6Ly9uYW11Lndpa2kvdy8lRUMlQTQlOTElRUElQjUlQUQlRUMlOUQlQjglRUMlOUQlOTg=">https://namu.wiki/w/중국인의<i class="fa fa-external-link-alt"></i></span> 나머지 정리))</p>
]]></content>
      <categories>
        <category>PS</category>
        <category>university</category>
      </categories>
      <tags>
        <tag>assignment</tag>
        <tag>codeforces</tag>
        <tag>review</tag>
      </tags>
  </entry>
  <entry>
    <title>Number of F cases</title>
    <url>/2020/03/26/2020-03-26-Number-of-F-cases/</url>
    <content><![CDATA[<span id="more"></span>

<h1>F를 받게되는 경우의 수</h1>

<h5>201901694 이동빈</h5>

<blockquote>
<p>총 수업시간 15*3 &#x3D; 45시간 중, 15시간 이상 결석하면 F를 받게 된다.</p>
</blockquote>
<p><strong>가정)</strong> </p>
<ol>
<li>출결체크는 매 수업시간 정각마다 이루어진다고 가정했습니다. (분 단위로 나누면 경우의 수가 너무 많음.)</li>
<li>공결, <del>출튀</del>, 수업 도중에 나갔다 들어오는 것과 같은 특수한 경우는 고려하진 않았습니다. (같은 이유.)</li>
</ol>
<hr>
<p><strong>45시간 중 15시간, 16시간, … , 45시간을 결석하면 F를 받게 되므로, 경우의 수는 다음과 같습니다.</strong></p>
<p>$$<br>\displaystyle\sum_{i&#x3D;15}^{45}\binom{45}{i} &#x3D; \displaystyle\sum_{i&#x3D;15}^{45}\frac{45!}{i!(45-i)!} &#x3D; <em>{45}C</em>{15} + <em>{45}C</em>{16} + … + <em>{45}C</em>{45}<br>$$<br><em>(계산 과정에서 45!의 값이 long long 범위를 넘어가서, 다른 방법으로 계산했습니다.)</em></p>
<hr>
<h4>Java</h4>

<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> homework <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> main <span class="token punctuation">(</span><span class="token class-name">String</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">long</span> answer <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> combination <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">long</span> b <span class="token operator">=</span> <span class="token number">45</span><span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> c <span class="token operator">&lt;=</span> <span class="token number">45</span><span class="token punctuation">;</span> b<span class="token operator">--</span><span class="token punctuation">,</span> c<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            combination <span class="token operator">=</span> <span class="token punctuation">(</span>combination <span class="token operator">*</span> b<span class="token punctuation">)</span> <span class="token operator">/</span> c<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">>=</span> <span class="token number">15</span><span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                answer <span class="token operator">+=</span> combination<span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"45 C "</span> <span class="token operator">+</span> c <span class="token operator">+</span> <span class="token string">" = "</span> <span class="token operator">+</span> combination<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"경우의 수 : "</span> <span class="token operator">+</span> answer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4>C++</h4>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;
#define ll long long
using namespace std;

int main()
&#123;
    ll answer &#x3D; 0;
    ll a &#x3D; 45;
    ll combination &#x3D; 1;
    for (ll b &#x3D; 45, c &#x3D; 1; c &lt;&#x3D; 45; b--, c++)
    &#123;
        combination &#x3D; (combination * b) &#x2F; c;
        if (c &gt;&#x3D; 15)
        &#123;
            answer +&#x3D; combination;
            printf(&quot;45 C %lld &#x3D; %lld\n&quot;, c, combination);
        &#125;
    &#125;
    printf(&quot;\n&quot;);

    printf(&quot;경우의 수 : %lld&quot;, answer);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4>출력 결과</h4>

<pre class="line-numbers language-none"><code class="language-none">45 C 15 &#x3D; 344867425584
45 C 16 &#x3D; 646626422970
45 C 17 &#x3D; 1103068603890
45 C 18 &#x3D; 1715884494940
45 C 19 &#x3D; 2438362177020
45 C 20 &#x3D; 3169870830126
45 C 21 &#x3D; 3773655750150
45 C 22 &#x3D; 4116715363800
45 C 23 &#x3D; 4116715363800
45 C 24 &#x3D; 3773655750150
45 C 25 &#x3D; 3169870830126
45 C 26 &#x3D; 2438362177020
45 C 27 &#x3D; 1715884494940
45 C 28 &#x3D; 1103068603890
45 C 29 &#x3D; 646626422970
45 C 30 &#x3D; 344867425584
45 C 31 &#x3D; 166871334960
45 C 32 &#x3D; 73006209045
45 C 33 &#x3D; 28760021745
45 C 34 &#x3D; 10150595910
45 C 35 &#x3D; 3190187286
45 C 36 &#x3D; 886163135
45 C 37 &#x3D; 215553195
45 C 38 &#x3D; 45379620
45 C 39 &#x3D; 8145060
45 C 40 &#x3D; 1221759
45 C 41 &#x3D; 148995
45 C 42 &#x3D; 14190
45 C 43 &#x3D; 990
45 C 44 &#x3D; 45
45 C 45 &#x3D; 1

경우의 수 : 34901237112896<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
      <categories>
        <category>university</category>
      </categories>
      <tags>
        <tag>assignment</tag>
      </tags>
  </entry>
  <entry>
    <title>About Strassen Algorithm</title>
    <url>/2020/04/11/2020-04-11-About-Strassen-Algorithm/</url>
    <content><![CDATA[<span id="more"></span>

<p>스트라센 알고리즘은 분할 정복을 이용한 알고리즘으로,</p>
<p>$O(n^3)$ 으로 알려진 행렬 곱셈을 약 $O(n^{2.807})$ 으로 더 빠르게 구하는 알고리즘입니다.</p>
<p>스트라센 알고리즘에 대한 이해를 돕기 위해, 일반적인 행렬 곱셈 방법부터 알아봅시다.</p>
<br />

<hr>
<h3 id="1-일반적인-행렬-곱셈"><a href="#1-일반적인-행렬-곱셈" class="headerlink" title="1.일반적인 행렬 곱셈"></a>1.일반적인 행렬 곱셈</h3><p>$AB &#x3D; C$ 를 만족하는 $n*n$ 크기의 행렬 $A, B, C$ 에서, 일반적인 행렬 곱셈 방법은 다음과 같습니다.<br>$$<br>AB &#x3D; C &#x3D;\begin{bmatrix}<br>\sum_{k&#x3D;1}^nA_{1k}B_{k1} &amp; \sum_{k&#x3D;1}^nA_{1k}B_{k2} &amp; \cdots &amp; \sum_{k&#x3D;1}^nA_{1k}B_{kn}<br>\\sum_{k&#x3D;1}^nA_{2k}B_{k1} &amp; \sum_{k&#x3D;1}^nA_{2k}B_{k2} &amp; \cdots &amp; \sum_{k&#x3D;1}^nA_{2k}B_{kn}<br>\\vdots &amp; \vdots &amp; \ddots &amp; \vdots<br>\\sum_{k&#x3D;1}^nA_{nk}B_{k1} &amp; \sum_{k&#x3D;1}^nA_{nk}B_{k2} &amp; \cdots &amp; \sum_{k&#x3D;1}^nA_{nk}B_{kn}<br>\end{bmatrix}<br>$$<br>이를 코드로 나타내면 아래와 같습니다.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void normal_mult(int n, int A[][], int B[][], int C[][])
&#123;
	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
		for (int j &#x3D; 1; j &lt;&#x3D; n; j++)
		&#123;
			C[i][j] &#x3D; 0; &#x2F;&#x2F;초기화. 미리 해두었다면 생략 가능.
			for (int k &#x3D; 1; k &lt;&#x3D; n; k++)
				C[i][j] +&#x3D; A[i][k] * B[k][j];
		&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="시간복잡도"><a href="#시간복잡도" class="headerlink" title="시간복잡도"></a>시간복잡도</h4><p>n번의 반복이 3중으로 일어나므로, 시간복잡도는 $O(n^3)$ 입니다.</p>
<br />

<hr>
<h3 id="2-분할정복을-이용한-행렬곱셈"><a href="#2-분할정복을-이용한-행렬곱셈" class="headerlink" title="2. 분할정복을 이용한 행렬곱셈"></a>2. 분할정복을 이용한 행렬곱셈</h3><p>$A*B &#x3D; C$ 를 만족하는 $n &#x3D; 2^k$ 크기의 행렬을 $2^{k-1}$ 크기의 4개의 부분행렬(submatrix)로 쪼개어, C의 값을 다음과 같이 구할 수 있습니다.<br>$$<br>C &#x3D; \begin{bmatrix}C_{11}&amp;C_{12}\C_{21}&amp;C_{22}\end{bmatrix},<br>A &#x3D; \begin{bmatrix}A_{11}&amp;A_{12}\A_{21}&amp;A_{22}\end{bmatrix},<br>B &#x3D; \begin{bmatrix}B_{11}&amp;B_{12}\B_{21}&amp;B_{22}\end{bmatrix}<br>$$</p>
<p>$$<br>C_{11}&#x3D;A_{11}B_{11}+A_{12}B_{21}<br>\C_{12}&#x3D;A_{11}B_{12}+A_{12}B_{22}<br>\C_{21}&#x3D;A_{21}B_{11}+A_{22}B_{21}<br>\C_{22}&#x3D;A_{21}B_{12}+A_{22}B_{22}<br>$$</p>
<h4 id="시간복잡도-1"><a href="#시간복잡도-1" class="headerlink" title="시간복잡도"></a>시간복잡도</h4><p>매 과정마다 <strong>부분행렬끼리의 <span style="color:red">8번의 곱셈</span>과</strong> <span style="color:blue">4번의 덧셈</span>이, 재귀적으로 위의 과정이 $k (&#x3D;log_2n)$ 번 반복됩니다. 이를 통해 시간복잡도를 증명해봅시다.  <em>(여기서 c는 덧셈, 대입 등의 상수복잡도입니다.)</em><br>$$<br>T(n)&#x3D;8T(\frac{n}{2})+c<br>\&#x3D;8[8T(\frac{n}{4})+c]+c<br>\&#x3D;8[8^2T(\frac{n}{8})+8c+c]+c<br>\&#x3D;8[8^3T(\frac{n}{16})+8^2c+8c+c]+c<br>\\vdots<br>\&#x3D;8^{log_2n}T(1)+\frac{8^{log_2n}-1}{8-1}c<br>\\approx 8^{log_2n}(T(1)+c)<br>\&#x3D;n^{log_28}(T(1)+c)&#x3D;n^3(T(1)+c)<br>\\implies O(n^3)<br>$$<br>이 방법으로도, 시간복잡도는 그대로 $O(n^3)$ 임을 알 수 있습니다. </p>
<br />

<hr>
<h3 id="3-스트라센-알고리즘"><a href="#3-스트라센-알고리즘" class="headerlink" title="3. 스트라센 알고리즘"></a>3. 스트라센 알고리즘</h3><p>위의 방법에서, <strong>부분행렬끼리의 <span style="color:red">곱셈 횟수를 7번으로 줄인</span></strong> 알고리즘이 바로 스트라센 알고리즘입니다.</p>
<p>그 방법은 다음과 같습니다.<br>$$<br>M_1&#x3D;(A_{11}+A_{22})(B_{11}+B_{22})<br>\M_2&#x3D;(A_{21}+A_{22})B_{11}<br>\M_3&#x3D;A_{11}(B_{12}−B_{22})<br>\M_4&#x3D;A_{22}(B_{21}−B_{11})<br>\M_5&#x3D;(A_{11}+A_{12})B_{22}<br>\M_6&#x3D;(A_{21}-A_{11})(B_{11}+B_{12})<br>\M_7&#x3D;(A_{12}-A_{22})(B_{21}+B_{22})<br>$$<br>$$<br>C_{11}&#x3D;M_1+M_4-M_5+M_7<br>\C_{12}&#x3D;M_3+M_5<br>\C_{21}&#x3D;M_2+M_4<br>\C_{22}&#x3D;M_1-M_2+M_3+M_6<br>$$</p>
<h4 id="시간복잡도-2"><a href="#시간복잡도-2" class="headerlink" title="시간복잡도"></a>시간복잡도</h4><p>매 과정마다 <strong>부분행렬끼리의 <span style="color:red">7번의 곱셈</span>과</strong> <span style="color:blue">6+6번의 덧셈, 4+2번의 뺄셈</span>이, 재귀적으로 위의 과정이 $k(&#x3D;log_2n)$ 번 반복됩니다. 마찬가지로 시간복잡도를 증명해봅시다.<br>$$<br>T(n)&#x3D;7T(\frac{n}{2^1})+c<br>\&#x3D;7[7T(\frac{n}{2^2})+c]+c<br>\&#x3D;7[7^2T(\frac{n}{2^3})+7c+c]+c<br>\&#x3D;7[7^3T(\frac{n}{2^4})+7^2c+7c+c]+c<br>\\vdots<br>\&#x3D;7^{log_2n}T(1)+\frac{7^{log_2n}-1}{7-1}c<br>\\approx 7^{log_2n}(T(1)+c)<br>\&#x3D;n^{log_27}(T(1)+c) \approx n^{2.807}(T(1)+c)<br>\\implies O(n^{2.807})<br>$$<br>이를 구현한 코드입니다. ($A[0] &#x3D; A_{11} , A[1] &#x3D; A_{12} , A[2] &#x3D; A_{21} , A[3] &#x3D; A_{22} 이고, M[0] &#x3D; M_1, …, M[6] &#x3D; M_7$ 입니다.) </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#define SIZE 1&lt;&lt;10 &#x2F;&#x2F;행렬의 크기. (n &#x3D;&#x3D; 2^k &#x3D;&#x3D; 1&lt;&lt;k)
using namespace std;

&#x2F;&#x2F;threshold : 임계값.(일정 크기 미만의 행렬은 일반적인 행렬곱 방식이 더 빠름.)
int size &#x3D; SIZE, threshold &#x3D; 5;

void normal_mult(int n, int** A, int** B, int*** C);
void strassen(int n, int** A, int** B, int*** C);
void sum(int n, int** A, int** B, int*** C);
void subtract(int n, int** A, int** B, int*** C);

int main()
&#123;
    &#x2F;&#x2F;실행시간 측정. 단위는 ms.
    clock_t start, end;
    double runtime;

    int** A, ** B, ** C;
    A &#x3D; (int**)malloc(sizeof(int*) * size);
    B &#x3D; (int**)malloc(sizeof(int*) * size);
    C &#x3D; (int**)malloc(sizeof(int*) * size);
    for (int row &#x3D; 0; row &lt; size; row++)
    &#123;
        A[row] &#x3D; (int*)malloc(sizeof(int) * size);
        B[row] &#x3D; (int*)malloc(sizeof(int) * size);
        C[row] &#x3D; (int*)malloc(sizeof(int) * size);
    &#125;

    &#x2F;&#x2F;A,B의 값 랜덤 설정.
    srand((unsigned)time(NULL));
    for (int row &#x3D; 0; row &lt; SIZE; row++)
        for (int col &#x3D; 0; col &lt; SIZE; col++)
        &#123;
            A[row][col] &#x3D; rand() % 1000;
            B[row][col] &#x3D; rand() % 1000;
            C[row][col] &#x3D; 0; &#x2F;&#x2F;미리 0으로 초기화.
        &#125;

    printf(&quot;[A]\n&quot;);
    for (int row &#x3D; 0; row &lt; SIZE; row++)
    &#123;
        for (int col &#x3D; 0; col &lt; SIZE; col++)
            printf(&quot;%3d &quot;, A[row][col]);
        printf(&quot;\n&quot;);
    &#125;
    printf(&quot;\n&quot;);

    printf(&quot;[B]\n&quot;);
    for (int row &#x3D; 0; row &lt; SIZE; row++)
    &#123;
        for (int col &#x3D; 0; col &lt; SIZE; col++)
            printf(&quot;%3d &quot;, B[row][col]);
        printf(&quot;\n&quot;);
    &#125;
    printf(&quot;\n&quot;);

    &#x2F;&#x2F;스트라센 알고리즘으로 행렬곱 구하기.
    start &#x3D; clock();
    strassen(size, A, B, &amp;C);
    end &#x3D; clock();
    
    printf(&quot;[스트라센 알고리즘으로 구한 행렬 C]\n&quot;);
    for (int row &#x3D; 0; row &lt; SIZE; row++)
    &#123;
        for (int col &#x3D; 0; col &lt; SIZE; col++)
            printf(&quot;%7d &quot;, C[row][col]);
        printf(&quot;\n&quot;);
    &#125;

    runtime &#x3D; (double)(end - start);
    printf(&quot;\nruntime : %lf ms&quot;, runtime);
    return 0;
&#125;

void strassen(int n, int** A, int** B, int*** C)
&#123;
    if (n &lt; threshold) &#x2F;&#x2F;일반적인 행렬곱 방법이 더 빠르면, 그걸로 실행.
    &#123;
        normal_mult(n, A, B, C);
        return;
    &#125;

    &#x2F;&#x2F;임시로 필요한 submatrix 동적 할당. 메모리 비용이 꽤 많이 들어감.
    int half &#x3D; n &#x2F; 2;
    int** subA[4], ** subB[4], ** subC[4], ** M[7];
    for (int num &#x3D; 0; num &lt; 4; num++)
    &#123;
        subA[num] &#x3D; (int**)malloc(sizeof(int*) * half);
        subB[num] &#x3D; (int**)malloc(sizeof(int*) * half);
        subC[num] &#x3D; (int**)malloc(sizeof(int*) * half);
    &#125;
    for (int num &#x3D; 0; num &lt; 7; num++)
        M[num] &#x3D; (int**)malloc(sizeof(int*) * half);

    &#x2F;&#x2F;subC의 값과 M의 값을 저장할 때 행렬 연산이 여러번 요구되므로, 임시 배열이 필요함. 
    int** temp_A &#x3D; (int**)malloc(sizeof(int*) * half);
    int** temp_B &#x3D; (int**)malloc(sizeof(int*) * half);

    for (int row &#x3D; 0; row &lt; half; row++)
    &#123;
        for (int num &#x3D; 0; num &lt; 4; num++)
        &#123;
            subA[num][row] &#x3D; (int*)malloc(sizeof(int) * half);
            subB[num][row] &#x3D; (int*)malloc(sizeof(int) * half);
            subC[num][row] &#x3D; (int*)malloc(sizeof(int) * half);
        &#125;
        for (int num &#x3D; 0; num &lt; 7; num++)
            M[num][row] &#x3D; (int*)malloc(sizeof(int) * half);

        temp_A[row] &#x3D; (int*)malloc(sizeof(int) * half);
        temp_B[row] &#x3D; (int*)malloc(sizeof(int) * half);
    &#125;

    &#x2F;&#x2F;submatrix에 각각 값 집어넣기.
    for (int row &#x3D; 0; row &lt; n; row++)
        for (int col &#x3D; 0; col &lt; n; col++)
        &#123;
            &#x2F;&#x2F;A_11, B_11, C_11부분.
            if (row &lt; half &amp;&amp; col &lt; half)
            &#123;
                subA[0][row][col] &#x3D; A[row][col];
                subB[0][row][col] &#x3D; B[row][col];
            &#125;
            &#x2F;&#x2F;A_12, B_12, C_12부분.
            else if (row &lt; half &amp;&amp; col &gt;&#x3D; half)
            &#123;
                subA[1][row][col - half] &#x3D; A[row][col];
                subB[1][row][col - half] &#x3D; B[row][col];
            &#125;
            &#x2F;&#x2F;A_21, B_21, C_21부분.
            else if (row &gt;&#x3D; half &amp;&amp; col &lt; half)
            &#123;
                subA[2][row - half][col] &#x3D; A[row][col];
                subB[2][row - half][col] &#x3D; B[row][col];
            &#125;
            &#x2F;&#x2F;A_22, B_22, C_22부분.
            else if (row &gt;&#x3D; half &amp;&amp; col &gt;&#x3D; half)
            &#123;
                subA[3][row - half][col - half] &#x3D; A[row][col];
                subB[3][row - half][col - half] &#x3D; B[row][col];
            &#125;
        &#125;

    &#x2F;&#x2F;M_1, ... , M_7에 값 저장하기.

    &#x2F;&#x2F;M_1.
    sum(half, subA[0], subA[3], &amp;temp_A);
    sum(half, subB[0], subB[3], &amp;temp_B);
    strassen(half, temp_A, temp_B, &amp;M[0]);

    &#x2F;&#x2F;M_2.
    sum(half, subA[2], subA[3], &amp;temp_A);
    strassen(half, temp_A, subB[0], &amp;M[1]);

    &#x2F;&#x2F;M_3.
    subtract(half, subB[1], subB[3], &amp;temp_B);
    strassen(half, subA[0], temp_B, &amp;M[2]);

    &#x2F;&#x2F;M_4.
    subtract(half, subB[2], subB[0], &amp;temp_B);
    strassen(half, subA[3], temp_B, &amp;M[3]);

    &#x2F;&#x2F;M_5.
    sum(half, subA[0], subA[1], &amp;temp_A);
    strassen(half, temp_A, subB[3], &amp;M[4]);

    &#x2F;&#x2F;M_6.
    subtract(half, subA[2], subA[0], &amp;temp_A);
    sum(half, subB[0], subB[1], &amp;temp_B);
    strassen(half, temp_A, temp_B, &amp;M[5]);

    &#x2F;&#x2F;M_7.
    subtract(half, subA[1], subA[3], &amp;temp_A);
    sum(half, subB[2], subB[3], &amp;temp_B);
    strassen(half, temp_A, temp_B, &amp;M[6]);


    &#x2F;&#x2F;C_1, ... , C_4에 값 저장하기.

    &#x2F;&#x2F;C_1.
    sum(half, M[0], M[3], &amp;temp_A);
    subtract(half, temp_A, M[4], &amp;temp_B);
    sum(half, temp_B, M[6], &amp;subC[0]);

    &#x2F;&#x2F;C_2.
    sum(half, M[2], M[4], &amp;subC[1]);

    &#x2F;&#x2F;C_3.
    sum(half, M[1], M[3], &amp;subC[2]);

    &#x2F;&#x2F;C_4.
    sum(half, M[0], M[2], &amp;temp_A);
    subtract(half, temp_A, M[1], &amp;temp_B);
    sum(half, temp_B, M[5], &amp;subC[3]);

    &#x2F;&#x2F;submatrix C_1, ... , C_4에 저장한 값을 최종적으로 배열 C에 대입.
    for (int row &#x3D; 0; row &lt; n; row++)
        for (int col &#x3D; 0; col &lt; n; col++)
        &#123;
            &#x2F;&#x2F;A_11, B_11, C_11부분.
            if (row &lt; half &amp;&amp; col &lt; half)
                (*C)[row][col] &#x3D; subC[0][row][col];
            &#x2F;&#x2F;A_12, B_12, C_12부분.
            else if (row &lt; half &amp;&amp; col &gt;&#x3D; half)
                (*C)[row][col] &#x3D; subC[1][row][col - half];
            &#x2F;&#x2F;A_21, B_21, C_21부분.
            else if (row &gt;&#x3D; half &amp;&amp; col &lt; half)
                (*C)[row][col] &#x3D; subC[2][row - half][col];
            &#x2F;&#x2F;A_22, B_22, C_22부분.
            else if (row &gt;&#x3D; half &amp;&amp; col &gt;&#x3D; half)
                (*C)[row][col] &#x3D; subC[3][row - half][col - half];
        &#125;

    &#x2F;&#x2F;너무 많은 메모리를 사용하게 되므로, 다 쓴 메모리 공간은 재사용할 수 있도록 free.
    for (int row &#x3D; 0; row &lt; half; row++)
    &#123;
        for (int num &#x3D; 0; num &lt; 4; num++)
        &#123;
            free(subA[num][row]);
            free(subB[num][row]);
            free(subC[num][row]);
        &#125;
        free(temp_A[row]); free(temp_B[row]);
        for (int num &#x3D; 0; num &lt; 7; num++)
            free(M[num][row]);
    &#125;
    for (int num &#x3D; 0; num &lt; 4; num++)
    &#123;
        free(subA[num]);
        free(subB[num]);
        free(subC[num]);
    &#125;
    free(temp_A); free(temp_B);
    for (int num &#x3D; 0; num &lt; 7; num++)
        free(M[num]);
&#125;

void sum(int n, int** A, int** B, int*** C)
&#123;
    for (int row &#x3D; 0; row &lt; n; row++)
        for (int col &#x3D; 0; col &lt; n; col++)
            (*C)[row][col] &#x3D; A[row][col] + B[row][col];
&#125;

void subtract(int n, int** A, int** B, int*** C)
&#123;
    for (int row &#x3D; 0; row &lt; n; row++)
        for (int col &#x3D; 0; col &lt; n; col++)
            (*C)[row][col] &#x3D; A[row][col] - B[row][col];
&#125;

void normal_mult(int n, int** A, int** B, int*** C)
&#123;
    for (int row &#x3D; 0; row &lt; n; row++)
        for (int col &#x3D; 0; col &lt; n; col++)
        &#123;
            (*C)[row][col] &#x3D; 0; &#x2F;&#x2F;초기화.
            for (int k &#x3D; 0; k &lt; n; k++)
                (*C)[row][col] +&#x3D; A[row][k] * B[k][col];
        &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>행렬곱의 실행 시간을 구하는 방법은 아래의 방법으로 구현했습니다. (위의 코드에도 포함되어 있습니다.)</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;ctime&gt;
using namespace std;

int main()
&#123;
    clock_t start, end;
    double runtime;
    start &#x3D; clock();
    strassen(size, A, B, &amp;C);
    end &#x3D; clock();
    runtime &#x3D; (double)(end - start);
    printf(&quot;\nruntime : %lf ms&quot;, runtime);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="4-실행-결과"><a href="#4-실행-결과" class="headerlink" title="4. 실행 결과"></a>4. 실행 결과</h3><ol>
<li>행렬곱 결과</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;n&#x3D;8일 때
[A]
764 935 140 625 515 727 977 937
173 110 930 875 997 587 370 392
655 865 321 844 414 470 147 425
735 693 815 386 419 397 705 130
241 920 905 691 745 846 370  23
466  23 483 834 526  68 105 133
505  39  92 957 933 662 533 874
728 508 935 441 732 728 875 826

[B]
540 552 810  98 930  10 185 812
593 473 439 948 740 577 636 527
212 283 455 383 762 187 942 315
278 616 978 732 956 280 913 624
937 858 530 474  58 626 268 648
766 152 288 268 823 809 738 492
261 893 556 115 202 631 924 501
  7 889 257 382 286 205 857  52

[스트라센 알고리즘으로 구한 행렬 C]
2471438 3546431 2970602 2381607 3200127 2467420 3818808 2776818
2082205 2573264 2471250 1940112 2515229 1896945 3155126 2178010
1958609 2317200 2427509 2126412 2862782 1621278 2702134 2210745
1969557 2366911 2409706 1759428 2717039 1722668 2864979 2286421
2502490 2368622 2536792 2379399 3075922 2284934 3298697 2482349
1172813 1592190 1813899 1193378 1761470  819580 1719419 1496899
2107921 3066848 2610089 1837043 2440076 1947826 3058744 2299530
2492871 3432802 2965821 2192074 3241612 2367360 3990993 2742400

runtime : 0.000000 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li>실행시간 비교 (strassen VS normal mult)</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;n&#x3D;16
strassen runtime : 0.000000 ms
normal runtime : 0.000000 ms
&#x2F;&#x2F;n&#x3D;32
strassen runtime : 2.000000 ms
normal runtime : 0.000000 ms
&#x2F;&#x2F;n&#x3D;64
strassen runtime : 15.000000 ms
normal runtime : 1.000000 ms
&#x2F;&#x2F;n&#x3D;128
strassen runtime : 104.000000 ms
normal runtime : 7.000000 ms
&#x2F;&#x2F;n&#x3D;256
strassen runtime : 712.000000 ms
normal runtime : 62.000000 ms
&#x2F;&#x2F;n&#x3D;512
strassen runtime : 5008.000000 ms
normal runtime : 586.000000 ms
&#x2F;&#x2F;n&#x3D;1024
strassen runtime : 34959.000000 ms
normal runtime : 6009.000000 ms
&#x2F;&#x2F;n&#x3D;2048
strassen runtime : 245181.000000 ms
normal runtime : 79973.000000 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>clock함수의 리턴값이 정수인가봅니다. 소수점은 표현되지 않았습니다.</p>
<p>visual studio 2019의 debug모드에서 실행한 결과인데, release모드에선 조금 더 빠르게 동작합니다.</p>
<p>코드에서는 임계값을 5로 설정했는데, 실제 실행시간을 보니 임계값이 더 높아야겠습니다.</p>
<p>(코드가 최적화[^1]되지 않아서인지도 모르겠습니다. 더 자세한 이유를 아시는 분은 댓글 남겨주세요!)</p>
<p>(실험중에 임계값을 높이면 실험의 의미가 없으므로 코드는 그대로 놔두겠습니다.)</p>
<p>아무튼 중요한 사실은, <strong>n의 값이 2배가 될 때마다 strassen의 실행시간 증가폭은 <span style="color:red">x7</span>정도로 유지되는 반면,  normal mult 방식의 실행시간 증가폭은 <span style="color:red">x8</span>(혹은 그 이상)이라는 것입니다.</strong> 위에서 증명한 시간복잡도와 비슷한 결과입니다.</p>
<br />

<p>이것으로 스트라센 알고리즘의 소개를 마치겠습니다. 감사합니다!</p>
<p>[^1]: 예를 들어, M_6, M_7은 subC를 구할 때 중복 사용되지 않으므로 따로 할당하지 않고 구하는 방법을 생각해 볼 수 있습니다.</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>university</category>
      </categories>
      <tags>
        <tag>assignment</tag>
      </tags>
  </entry>
  <entry>
    <title>Greedy Algorithm</title>
    <url>/2020/04/16/2020-04-16-Greedy-Algorithm/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="Codeforces-Round-635-Div-2-C-문제"><a href="#Codeforces-Round-635-Div-2-C-문제" class="headerlink" title="Codeforces Round #635 (Div. 2) #C 문제"></a><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzEzMzcvcHJvYmxlbS9D">Codeforces Round #635 (Div. 2) #C 문제<i class="fa fa-external-link-alt"></i></span></h2><p>오늘은 4&#x2F;15 어제밤에 치뤘던 대회의 <code>greedy algorithm</code> 문제에 대해 소개드리겠습니다.</p>
<p><img src="/%5Csource%5Cimages%5C2020-04-16%5CC.JPG" alt="C"></p>
<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><ul>
<li>왕국에는 <span style="color:blue"><code>n</code></span>개의 도시와 <span style="color:blue"><code>n-1</code></span>개의 양방향 도로가 있다.</li>
<li>어느 도시에서든, 다른 도시로 가는 길이 존재한다.</li>
<li>도시는 <code>1</code>부터 <code>n</code>까지 번호가 매겨져 있고, <strong>도시 <code>1</code>은 왕국의 <span style="color:green">수도</span>이다. <span style="color:red">&#x3D;&gt; (트리 구조)</span></strong></li>
<li>Linova는 정확히 <span style="color:blue"><code>k</code></span>개의 도시를 선택하여, <span style="color:purple">산업도시</span>로 만들것이다.</li>
<li>1년에 한번  <span style="color:green">수도</span>에서 회의가 열린다. 회의에 참석하기 위해 각 <span style="color:purple">산업도시</span>에서 <span style="color:skyblue">사절</span>을 보낸다. 모든 <span style="color:skyblue">사절</span>들은 <span style="color:red">가장 짧은 경로</span>로 <span style="color:green">수도</span>로 향한다.</li>
<li><span style="color:green">수도</span>로 가는 길에, 각 <span style="color:skyblue">사절</span>은 그가 가는 길의 <span style="color:purple">관광도시</span> 수 만큼 <span style="color:blue">행복함</span>을 느낀다.</li>
<li>Linova는 모든 <span style="color:skyblue">사절</span>들의 <span style="color:blue">행복함</span>의 합이 최대가 되도록 <span style="color:blue"><code>k</code></span>개의 도시를 선택하고 싶어한다.</li>
</ul>
<br />

<h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><ul>
<li>첫 번째 줄에 두 개의 정수 <span style="color:blue"><code>n</code>(도시의 수)</span>과 <span style="color:purple"><code>k</code>(산업도시 수)</span> $(2≤n≤2⋅10^5, 1≤k&lt;n)$ 가 주어진다.</li>
<li>다음 n-1개의 줄에 각각 두 개의 정수 <span style="color:blue"><code>u</code></span>와 <span style="color:blue"><code>v</code></span> $(1≤u,v≤n)$ 가 주어지며, 이는 <span style="color:blue">도시 <code>u</code></span>와<span style="color:blue">도시 <code>v</code></span>를 연결하는 도로가 있음을 나타낸다.</li>
</ul>
<br />

<h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><ul>
<li>모든 <span style="color:skyblue">사절</span>들의 <span style="color:blue">행복함</span>의 최대 합계를 출력한다.</li>
</ul>
<br />

<br />

<br />

<hr>
<h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><p>우선, 수도(루트 노드)로 가는 사절들의 최단 경로의 길이는, 해당 산업도시의 레벨의 값과 같습니다.</p>
<p>다음의 예제를 트리로 그려봅시다.</p>
<p><img src="/%5Csource%5Cimages%5C2020-04-16%5CExample.JPG" alt="Example"></p>
<p><img src="/%5Csource%5Cimages%5C2020-04-16%5Ctree.png" alt="tree"></p>
<p>이 상태에서, 각 노드의 레벨은 <strong><code>DFS</code></strong> 로 구현할 수 있습니다.</p>
<br />

<p>그 코드입니다.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; tree[200001];
int lv[200001];

void go(int node, int level, int parent)
&#123;
	lv[node] &#x3D; level; &#x2F;&#x2F;현재 자신의 레벨값 저장.
	int size &#x3D; tree[node].size(); &#x2F;&#x2F;각 도시와 인접한 도시의 수
	for (int i &#x3D; 0; i &lt; size; i++)
		if (parent !&#x3D; tree[node][i]) &#x2F;&#x2F;부모가 아닌 모든 인접 노드(자식 노드)를 방문하면서,
			go(tree[node][i], level + 1, node); &#x2F;&#x2F;자식 노드이므로 level+1. 그 부모는 현재 자신.
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<br />

<p>이렇게 모든 노드의 레벨을 <code>lv</code>배열에 저장해놓고, 값을 출력해보면 다음과 같습니다.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for (int i &#x3D; 1; i &lt;&#x3D; N; i++)
		printf(&quot;lv[%d] &#x3D; %d\n&quot;, i, lv[i]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">lv[1] &#x3D; 0
lv[2] &#x3D; 1
lv[3] &#x3D; 2
lv[4] &#x3D; 3
lv[5] &#x3D; 2
lv[6] &#x3D; 1
lv[7] &#x3D; 1
lv[8] &#x3D; 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<br />

<p>우리가 원하는 값은 모든 <span style="color:skyblue">사절</span>들의 <span style="color:blue">행복함</span>의 최대 합계이므로, <strong>매 순간마다 <code>lv</code>값이 가장 큰 도시를 <span style="color:blue"><code>k</code></span>번 선택합니다. (greedy)</strong> 지난시간에 배운 <code>분할정복</code>을 이용한 <code>merge sort</code> 또는 <code>quick sort</code>로 레벨값을 내림차순 정렬한 후 <span style="color:blue"><code>k</code></span>개 만큼의 합을 구하면 될 듯 합니다. <code>nlogn</code>의 시간복잡도입니다.</p>
<br />

<p><code>C++</code> 에는<code>nlogn</code> 시간복잡도로 정렬해주는 <code>sort</code>함수가 <code>#include &lt;algorithm&gt;</code> 헤더 파일에 있으므로, 그걸 사용하겠습니다.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt; &#x2F;&#x2F; sort()
#include &lt;functional&gt; &#x2F;&#x2F;greater&lt;&gt;()
#define ll long long
using namespace std;

vector&lt;int&gt; tree[200001];
int lv[200001];

void go(int node, int level, int parent)
&#123;
	lv[node] &#x3D; level;
	int size &#x3D; tree[node].size();
	for (int i &#x3D; 0; i &lt; size; i++)
		if (parent !&#x3D; tree[node][i])
			go(tree[node][i], level + 1, node);
&#125;

int main()
&#123;
	int N, k, u, v;
	scanf(&quot;%d %d&quot;, &amp;N, &amp;k);
	for (int i &#x3D; 1; i &lt; N; i++)
	&#123;
		scanf(&quot;%d %d&quot;, &amp;u, &amp;v);
		&#x2F;&#x2F;양방향 도로
		tree[u].push_back(v);
		tree[v].push_back(u);
	&#125;

	go(1, 0, 1);
	sort(lv + 1, lv + 1 + N, greater&lt;&gt;()); &#x2F;&#x2F;내림차순 정렬

	ll ans &#x3D; 0; &#x2F;&#x2F;값이 int형 범위를 넘어갈 수 있습니다.
	for (int i &#x3D; 1; i &lt;&#x3D; k; i++)
		ans +&#x3D; (ll)lv[i];
	printf(&quot;%lld&quot;, ans);
	return 0;
&#125;

&#x2F;&#x2F;출력결과 : 11.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>값이 <code>11</code>이 나옵니다. 예제의 답 <code>9</code>와 다르네요.</p>
<p>그 이유에 대해 생각해봅시다.</p>
<br />

<hr>
<p>위의 <code>lv</code>배열을 내림차순으로 정렬하면, <code>&#123;3,3,2,2,1,1,1,0&#125;</code> 이 됩니다. 따라서 <span style="color:blue"><code>k</code></span> 가 <code>5</code>로 주어졌으므로, <code>3+3+2+2+1 = 11</code>을 출력한 것입니다. 이 경우를 그림으로 나타내봅시다.</p>
<p>![wrong example](\source\images\2020-04-16\wrong example.png)</p>
<p>위의 그림에서 <span style="color:green"><code>4번 도시</code></span>, <span style="color:green"><code>8번 도시</code></span>를 고를때까진 문제가 없습니다. 하지만 <span style="color:skyblue"><code>5번 도시</code></span>와 <span style="color:skyblue"><code>3번 도시</code></span>를 고를때,</p>
<p><strong>이 도시들이 <span style="color:purple">관광도시</span>에서 <span style="color:purple">산업도시</span>로 바뀌는 과정에서 <span style="color:green"><code>4번 사절</code></span>과 <span style="color:green"><code>8번 사절</code></span>의 <span style="color:blue">행복함</span>이 1씩 감소하게됩니다.</strong> </p>
<p>그렇다면, <code>x</code>번 도시가 <span style="color:purple">산업도시</span>로 선택됨으로 인해  <span style="color:blue">행복함</span>이 감소되는 사절의 수는 어떻게 구할까요?</p>
<p>그 답은 <strong><code>x</code>번 도시의 <span style="color:blue"><code>자손 노드의 수</code></span></strong> 입니다. 왜냐하면 우리는 레벨이 높은 도시부터 우선적으로 골라왔기때문에, 어떤 노드를 고를 때 그 자손 노드들은 이미 다 선택되어있을 것입니다. 따라서 다음과 같은 상황이 됩니다.</p>
<p>![corrected example](\source\images\2020-04-16\corrected example.png)</p>
<p>따라서 <code>2+2+2+2+1 = 9</code>로 정확한 답이 됩니다. <em>(위의 그림에서 <code>7</code>을 고른다면 답보다 값이 작아집니다.)</em></p>
<p>답을 출력하기 위한 과정은 다음과 같습니다.</p>
<ul>
<li><strong><code>DFS</code></strong> 과정에서 각 노드의 <span style="color:blue"><code>자손 노드</code></span>의 수를 저장하는 <code>descendant</code>배열을 만듭니다.</li>
<li>도시 <code>x</code>를 선택할 때 발생하는 <span style="color:blue">행복함</span>의 값은, <strong><code>lv[x]</code> - <code>descendant[x]</code></strong> 입니다. (자손 노드의 수만큼 총 <span style="color:blue">행복함</span> 값이 감소하고, 자신의 <code>lv</code>값 만큼 <span style="color:blue">행복함</span>이 증가하므로)</li>
<li><strong>위의 값이 큰것부터 <span style="color:blue"><code>k</code></span>개를 뽑아 더한 값을 출력하면 됩니다.(greedy)</strong></li>
</ul>
<br />

<p>그 코드입니다.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#define ll long long
using namespace std;

vector&lt;int&gt; tree[200001];
int lv[200001];
int descendant[200001];

int go(int node, int level, int parent)
&#123;
	lv[node] &#x3D; level;
	int size &#x3D; tree[node].size(), d &#x3D; 0;

	for (int i &#x3D; 0; i &lt; size; i++)
		if (parent !&#x3D; tree[node][i])
		&#x2F;&#x2F;[현재 자식의 자손 수 + 현재 자식노드(1)]을 모든 자식에 대해 반복 &#x3D;&gt; 현재 노드의 총 자손 수
			d +&#x3D; go(tree[node][i], level + 1, node) + 1;

	return descendant[node] &#x3D; d;
&#125;

int main()
&#123;
	int N, k, u, v;
	scanf(&quot;%d %d&quot;, &amp;N, &amp;k);
	for (int i &#x3D; 1; i &lt; N; i++)
	&#123;
		scanf(&quot;%d %d&quot;, &amp;u, &amp;v);
		tree[u].push_back(v);
		tree[v].push_back(u);
	&#125;

	go(1, 0, 1);
	for (int i &#x3D; 1; i &lt;&#x3D; N; i++)
		lv[i] -&#x3D; descendant[i];
	sort(lv + 1, lv + 1 + N, greater&lt;&gt;());

	ll ans &#x3D; 0;
	for (int i &#x3D; 1; i &lt;&#x3D; k; i++)
		ans +&#x3D; (ll)lv[i];
	printf(&quot;%lld&quot;, ans);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
      <categories>
        <category>PS</category>
        <category>university</category>
      </categories>
      <tags>
        <tag>assignment</tag>
        <tag>codeforces</tag>
        <tag>review</tag>
      </tags>
  </entry>
  <entry>
    <title>Programming-TeamProject</title>
    <url>/2020/05/31/2020-05-31-Programming-TeamProject/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="프로그래밍-팀프로젝트"><a href="#프로그래밍-팀프로젝트" class="headerlink" title="프로그래밍 팀프로젝트"></a>프로그래밍 팀프로젝트</h1><h3 id="좀비-게임-변경-사항-x2F-오류-제보"><a href="#좀비-게임-변경-사항-x2F-오류-제보" class="headerlink" title="좀비 게임 (변경 사항&#x2F;오류 제보)"></a>좀비 게임 (변경 사항&#x2F;오류 제보)</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RvbmdiaW4xOTk5L1Byb2dyYW1taW5nLVRlYW1Qcm9qZWN0">Download<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li>Ver 1.0<ul>
<li>게임의 첫 버전입니다.</li>
</ul>
</li>
<li>Ver 1.1<br>*<br>* <ul>
<li></li>
</ul>
</li>
</ul>
<blockquote>
<p>기타 오류사항 발견 시 <strong>하단의 댓글</strong> 또는</p>
<p><span class="exturl" data-url="bWFpbHRvOiYjeDY0OyYjMTExOyYjeDZlOyYjMTAzOyYjOTg7JiMxMDU7JiMxMTA7JiM0OTsmI3gzOTsmIzU3OyYjeDM5OyYjNjQ7JiMxMDU7JiN4NmU7JiN4NzU7JiM0NjsmIzk3OyYjOTk7JiM0NjsmI3g2YjsmI3g3Mjs=">&#x64;&#111;&#x6e;&#103;&#98;&#105;&#110;&#49;&#x39;&#57;&#x39;&#64;&#105;&#x6e;&#x75;&#46;&#97;&#99;&#46;&#x6b;&#x72;<i class="fa fa-external-link-alt"></i></span> 로 의견 남겨주시면 감사하겠습니다!</p>
</blockquote>
]]></content>
      <categories>
        <category>university</category>
      </categories>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>Programming project - Game Demo</title>
    <url>/2020/04/25/2020-04-25-Programming-project---Game-Demo/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="프로그래밍-프로젝트"><a href="#프로그래밍-프로젝트" class="headerlink" title="프로그래밍 프로젝트"></a>프로그래밍 프로젝트</h1><h3 id="장애물-피하기-게임-변경-사항-x2F-오류-제보"><a href="#장애물-피하기-게임-변경-사항-x2F-오류-제보" class="headerlink" title="장애물 피하기 게임 (변경 사항&#x2F;오류 제보)"></a>장애물 피하기 게임 (변경 사항&#x2F;오류 제보)</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RvbmdiaW4xOTk5L1Byb2dyYW1taW5nLVByb2plY3Q=">Download<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li>Ver 1.0<ul>
<li>게임의 첫 버전입니다.</li>
</ul>
</li>
<li>Ver 1.1<ul>
<li>게임내 글씨, 물체들의 색깔을 다양하게 수정하였습니다.</li>
<li>물체와 캐릭터간의 y축 충돌이 제대로 일어나지 않는 오류를 수정했습니다.</li>
<li>출처, 연락처 등의 내용을 추가하였습니다.</li>
</ul>
</li>
</ul>
<blockquote>
<p>기타 오류사항 발견 시 <strong>하단의 댓글</strong> 또는</p>
<p><span class="exturl" data-url="bWFpbHRvOiYjeDY0OyYjMTExOyYjMTEwOyYjMTAzOyYjeDYyOyYjeDY5OyYjMTEwOyYjNDk7JiN4Mzk7JiN4Mzk7JiM1NzsmIzY0OyYjeDY5OyYjMTEwOyYjMTE3OyYjeDJlOyYjeDYxOyYjOTk7JiN4MmU7JiMxMDc7JiN4NzI7">&#x64;&#111;&#110;&#103;&#x62;&#x69;&#110;&#49;&#x39;&#x39;&#57;&#64;&#x69;&#110;&#117;&#x2e;&#x61;&#99;&#x2e;&#107;&#x72;<i class="fa fa-external-link-alt"></i></span> 로 의견 남겨주시면 감사하겠습니다!</p>
</blockquote>
]]></content>
      <categories>
        <category>university</category>
      </categories>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>Floyd-Warshall</title>
    <url>/2021/01/24/2021-01-24-Floyd-Warshall/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="플로이드-와샬-알고리즘"><a href="#플로이드-와샬-알고리즘" class="headerlink" title="플로이드 와샬 알고리즘"></a>플로이드 와샬 알고리즘</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;

&#x2F;&#x2F;간선 입력 전에, adj 배열 1e9로 초기화.
int adj[101][101];
void floyd_warshall(int n)
&#123;
    for(int via&#x3D;1;via&lt;&#x3D;n;via++)
        for(int s&#x3D;1;s&lt;&#x3D;n;s++)
            for(int e&#x3D;1;e&lt;&#x3D;n;e++)
                if(s!&#x3D;e)
                    adj[s][e]&#x3D;min(adj[s][e],adj[s][via]+adj[via][e]);

    &#x2F;&#x2F;출력. adj[i][j] : i-&gt;j에 필요한 최소 비용.
    for(int i&#x3D;1;i&lt;&#x3D;n;i++)
    &#123;
        for(int j&#x3D;1;j&lt;&#x3D;n;j++)
            printf(&quot;%d &quot;,adj[i][j]&#x3D;&#x3D;1e9?0:adj[i][j]);
        printf(&quot;\n&quot;);
    &#125;
&#125;

int main()
&#123;
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    for(int i&#x3D;1;i&lt;&#x3D;n;i++)
        fill(adj[i]+1,adj[i]+1+n,1e9);
    while(m--)
    &#123;
        int a,b,c;
        scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c);
        adj[a][b]&#x3D;min(adj[a][b],c);
    &#125;
    floyd_warshall(n);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="시간복잡도"><a href="#시간복잡도" class="headerlink" title="시간복잡도"></a>시간복잡도</h2><p>$O(V^3)$</p>
<blockquote>
<p>V : 정점 수</p>
</blockquote>
<h2 id="관련문제"><a href="#관련문제" class="headerlink" title="관련문제"></a>관련문제</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8xMTQwNA==">백준11404 : 플로이드<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Floyd-Warshall</tag>
      </tags>
  </entry>
  <entry>
    <title>Bellman-Ford</title>
    <url>/2021/01/24/2021-01-24-Bellman-Ford/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="벨만-포드-알고리즘"><a href="#벨만-포드-알고리즘" class="headerlink" title="벨만 포드 알고리즘"></a>벨만 포드 알고리즘</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
#define ll long long
#define pil pair&lt;int,ll&gt;
using namespace std;

ll dist[501];
vector&lt;pil&gt; graph[501];

&#x2F;&#x2F;음의 사이클이 발생하면 false 리턴. n:정점 개수.
bool bellman_ford(int n)
&#123;
    fill(dist+1,dist+1+n,1e18); dist[1] &#x3D; 0;
    int loop&#x3D;n-1;
    while(loop--)
        for(int s&#x3D;1;s&lt;&#x3D;n;s++)
            for(pil go:graph[s])
                if(dist[s]!&#x3D;1e18)
                    dist[go.first]&#x3D;min(dist[go.first],dist[s]+go.second);

    &#x2F;&#x2F;한번더 돌아서 값이 갱신되면, 음의 사이클이 존재하는 것.
    for(int s&#x3D;1;s&lt;&#x3D;n;s++)
        for(pil go:graph[s])
            if(dist[go.first]&gt;dist[s]+go.second&amp;&amp;dist[go.first]!&#x3D;1e18)
                return false;

    for(int i&#x3D;2;i&lt;&#x3D;n;i++)
        printf(&quot;%lld\n&quot;,dist[i]&#x3D;&#x3D;1e18?-1ll:dist[i]);
    return true;
&#125;

int main()
&#123;
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    while(m--)
    &#123;
        int a,b;ll c;
        scanf(&quot;%d %d %lld&quot;,&amp;a,&amp;b,&amp;c);
        graph[a].push_back(&#123;b,c&#125;);
    &#125;
    bool ok&#x3D;bellman_ford(n);
    if(!ok) printf(&quot;-1&quot;);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="시간복잡도"><a href="#시간복잡도" class="headerlink" title="시간복잡도"></a>시간복잡도</h2><p>$O(VE)$</p>
<blockquote>
<p>V : 정점 수, E : 간선 수</p>
</blockquote>
<h2 id="관련문제"><a href="#관련문제" class="headerlink" title="관련문제"></a>관련문제</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8xMTY1Nw==">백준11657 : 타임머신<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Bellman-Ford</tag>
      </tags>
  </entry>
  <entry>
    <title>LCA(lowest common ancestor)</title>
    <url>/2021/01/24/2021-01-24-LCA(lowest%20common%20ancestor)/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="최소-공통-조상"><a href="#최소-공통-조상" class="headerlink" title="최소 공통 조상"></a>최소 공통 조상</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
const int sz&#x3D;17;
&#x2F;&#x2F;(1&lt;&lt;sz)&gt;&#x3D;n이 되게 관리.
vector&lt;int&gt; tree[1&lt;&lt;sz];
int depth[1&lt;&lt;sz];&#x2F;&#x2F;depth[i] : i번 노드의 깊이(루트노드에서부터의 거리)
int sparse[1&lt;&lt;sz][sz];&#x2F;&#x2F;sparse[i][j] : i번째 노드의 2^j번째 부모. 1번(루트)노드의 부모도 1이라고 가정.

void go(int node,int d,int parent)
&#123;
    sparse[node][0]&#x3D;parent;
    depth[node]&#x3D;d;
    &#x2F;&#x2F;어떤 노드의 2^i번째 부모는, 그 노드의 2^(i-1)번째 부모의 2^(i-1)번째 부모임.
    for(int i&#x3D;1;i&lt;sz;i++)
        sparse[node][i]&#x3D;sparse[sparse[node][i-1]][i-1];
    for(int to:tree[node])
        if(parent!&#x3D;to)
            go(to,d+1,node);
&#125;

int LCA(int a,int b)
&#123;
    if(depth[a]&gt;depth[b])
        swap(a,b);&#x2F;&#x2F;b가 더 깊은 점.
    for(int i&#x3D;sz-1;i&gt;&#x3D;0;i--)&#x2F;&#x2F;b를 a 높이까지 올려줌.
        if(depth[sparse[b][i]]&gt;&#x3D;depth[a])
            b&#x3D;sparse[b][i];
    if(a&#x3D;&#x3D;b)return a;&#x2F;&#x2F;a,b가 같은 점이면 그 점이 LCA.
    for(int i&#x3D;sz-1;i&gt;&#x3D;0;i--)
        if(sparse[a][i]!&#x3D;sparse[b][i])
            a&#x3D;sparse[a][i],b&#x3D;sparse[b][i];
    return sparse[a][0];&#x2F;&#x2F;a,b의 한단계 위가 LCA.
&#125;

int main()
&#123;
    int n,m;
    scanf(&quot;%d&quot;, &amp;n);
    for(int i&#x3D;1;i&lt;n;i++)
    &#123;
        int a,b;
        scanf(&quot;%d %d&quot;,&amp;a,&amp;b);
        tree[a].push_back(b);
        tree[b].push_back(a);
    &#125;
    go(1,0,1);
    scanf(&quot;%d&quot;,&amp;m);
    while(m--)
    &#123;
        int a,b;
        scanf(&quot;%d %d&quot;,&amp;a,&amp;b);
        printf(&quot;%d\n&quot;,LCA(a,b));
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="시간복잡도"><a href="#시간복잡도" class="headerlink" title="시간복잡도"></a>시간복잡도</h2><ul>
<li>전처리 : $O(NlogN)$</li>
<li>LCA 찾기 : $O(logN)$</li>
</ul>
<blockquote>
<p>N : 노드 수</p>
</blockquote>
<h2 id="관련문제"><a href="#관련문제" class="headerlink" title="관련문제"></a>관련문제</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8xMTQzOA==">백준11438 : LCA 2<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>MST(minimum spanning tree)</title>
    <url>/2021/01/24/2021-01-24-MST(minimum%20spanning%20tree)/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="최소-스패닝-트리"><a href="#최소-스패닝-트리" class="headerlink" title="최소 스패닝 트리"></a>최소 스패닝 트리</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
#define pii pair&lt;int,int&gt;
using namespace std;

struct element
&#123;
	int u,v,w;
&#125;;

bool operator&lt;(element a,element b)
&#123;
    return a.w&gt;b.w;
&#125;

vector&lt;pii&gt; tree[10001];
int u[10001];
priority_queue&lt;element&gt; pq;

&#x2F;&#x2F;크루스칼 알고리즘 사용. 연결 여부를 union-find로 판별.
int find(int a)
&#123;
    if(u[a]&lt;0)return a;
    return u[a]&#x3D;find(u[a]);
&#125;

bool merge(int a,int b)
&#123;
    a&#x3D;find(a),b&#x3D;find(b);
    if(a&#x3D;&#x3D;b)return false;
    if(-u[a]&lt;-u[b])swap(a,b);
    u[a]+&#x3D;u[b],u[b]&#x3D;a;
    return true;
&#125;

&#x2F;&#x2F;v: 정점의 개수. main 에서 pq에 간선 넣고, u배열 -1로 초기화. mst의 가중치 리턴.
int mst(int v)
&#123;
    int weight&#x3D;0;
    while (!pq.empty())
    &#123;
        element e&#x3D;pq.top();
        pq.pop();
        if(merge(e.u,e.v))
        &#123;
            weight+&#x3D;e.w;
            tree[e.u].push_back(&#123;e.v,e.w&#125;);
            tree[e.v].push_back(&#123;e.u,e.w&#125;);
        &#125;
    &#125;
    return weight;
&#125;

int main()
&#123;
	int v,e;
	scanf(&quot;%d %d&quot;,&amp;v,&amp;e);
	while(e--)
	&#123;
	    int a,b,c;
		scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c);
		pq.push(&#123;a,b,c&#125;);
	&#125;
	fill(u+1,u+1+v,-1);
	printf(&quot;%d&quot;,mst(v));
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="시간복잡도"><a href="#시간복잡도" class="headerlink" title="시간복잡도"></a>시간복잡도</h2><p>$O(ElogE) (&#x3D;O(ElogE)+O(Elog*V))$</p>
<blockquote>
<p>V : 정점 수, E : 간선 수</p>
</blockquote>
<h2 id="관련문제"><a href="#관련문제" class="headerlink" title="관련문제"></a>관련문제</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8xMTk3">백준1197 : 최소 스패닝 트리<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>MST</tag>
      </tags>
  </entry>
  <entry>
    <title>dijkstra</title>
    <url>/2021/01/24/2021-01-24-dijkstra/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="다익스트라-알고리즘"><a href="#다익스트라-알고리즘" class="headerlink" title="다익스트라 알고리즘"></a>다익스트라 알고리즘</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
#define pii pair&lt;int,int&gt;
using namespace std;

&#x2F;&#x2F;노드 수에 맞게 크기 조정.
vector&lt;pii&gt; graph[20001];
bool vis[20001];
int dist[20001];

&#x2F;&#x2F;v: 노드의 수, k: 시작 정점.
void dijkstra(int v, int k)
&#123;
    fill(vis+1,vis+1+v,false);
    fill(dist+1,dist+1+v,1e9), dist[k]&#x3D;0;&#x2F;&#x2F;k-&gt;k 제외 거리 무한대.
    priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;
    pq.push(&#123;0,k&#125;);
    while(!pq.empty())
    &#123;
        pii cur&#x3D;pq.top();
        pq.pop();
        if(vis[cur.second]) continue;
        &#x2F;&#x2F;처음 node에 도달한 경우가 최소 비용.
        vis[cur.second]&#x3D;true, dist[cur.second]&#x3D;cur.first;
        for(auto go:graph[cur.second]) &#x2F;&#x2F;갈수있는 모든정점 방문.
            pq.push(&#123;cur.first+go.second,go.first&#125;);
    &#125;

    &#x2F;&#x2F;출력.
    for(int i&#x3D;1;i&lt;&#x3D;v;i++)
        if (dist[i]&#x3D;&#x3D;1e9)
            printf(&quot;INF\n&quot;);
        else
            printf(&quot;%d\n&quot;,dist[i]);
&#125;

int main(void)
&#123;
    int v,e,k;
    scanf(&quot;%d %d %d&quot;,&amp;v,&amp;e,&amp;k);
    while(e--)
    &#123;
        int a,b,w;
        scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;w);
        graph[a].push_back(&#123;b,w&#125;);
      &#x2F;&#x2F;graph[b].push_back(&#123;a,w&#125;);&#x2F;&#x2F;방향그래프.
    &#125;
    dijkstra(v,k);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="시간복잡도"><a href="#시간복잡도" class="headerlink" title="시간복잡도"></a>시간복잡도</h2><p>$O(ElogV)$</p>
<blockquote>
<p>V : 정점 수, E : 간선 수</p>
</blockquote>
<h2 id="관련문제"><a href="#관련문제" class="headerlink" title="관련문제"></a>관련문제</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8xNzUz">백준1753 : 최단경로<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>union-find</title>
    <url>/2021/01/24/2021-01-24-union-find/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="분리-집합"><a href="#분리-집합" class="headerlink" title="분리 집합"></a>분리 집합</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;

&#x2F;&#x2F;처음에 u 배열 -1로 초기화.
int u[1000001];

int find(int a)
&#123;
    if(u[a]&lt;0)return a;
    return u[a]&#x3D;find(u[a]);
&#125;

bool merge(int a,int b)
&#123;
    a&#x3D;find(a),b&#x3D;find(b);
    if(a&#x3D;&#x3D;b)return false;
    &#x2F;&#x2F;union by rank. path compression을 하지 않을 때 사용.
    &#x2F;&#x2F;if(-u[a]&lt;-u[b])swap(a,b);
    u[a]+&#x3D;u[b],u[b]&#x3D;a;
    return true;
&#125;

int main(void)
&#123;
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    fill(u,u+1+n,-1);
    while(m--)
    &#123;
        int c,a,b;
        scanf(&quot;%d %d %d&quot;,&amp;c,&amp;a,&amp;b);
        if(c) printf(find(a)&#x3D;&#x3D;find(b)?&quot;YES\n&quot;:&quot;NO\n&quot;);
        else merge(a,b);
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="시간복잡도"><a href="#시간복잡도" class="headerlink" title="시간복잡도"></a>시간복잡도</h2><p>$O(Mlog*N) \approx O(M)$</p>
<blockquote>
<p>N : 정점 수, M : find 연산 수행 횟수</p>
</blockquote>
<h2 id="관련문제"><a href="#관련문제" class="headerlink" title="관련문제"></a>관련문제</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8xNzE3">백준1717 : 집합의 표현<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>union-find</tag>
      </tags>
  </entry>
  <entry>
    <title>SCC(strongly connected component)</title>
    <url>/2021/01/24/2021-01-24-SCC(strongly%20connected%20component)/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="강한-연결-요소"><a href="#강한-연결-요소" class="headerlink" title="강한 연결 요소"></a>강한 연결 요소</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
const int sz&#x3D;100001;
&#x2F;&#x2F;sz : n+1로 설정.
int dfsn[sz],scc[sz],dfsnumber,sccnumber;
&#x2F;&#x2F;graph : 처음 주어지는 그래프 &#x2F; dag : SCC로 묶인 그래프 &#x2F; group[i] : i번 scc 노드에 묶여있는 노드들.
vector&lt;int&gt; graph[sz],dag[sz],group[sz];
stack&lt;int&gt; s;
int indegree[sz];

&#x2F;&#x2F;타잔 알고리즘 이용.(scc 결과의 역순이 위상정렬한 dag 의 결과와 같음.)
int SCC(int node)
&#123;
    dfsn[node]&#x3D;++dfsnumber;
    s.push(node);
    int topmost&#x3D;dfsn[node];
    for(int to:graph[node])
        if(!dfsn[to]) topmost&#x3D;min(topmost, SCC(to));
        else if(!scc[to]) topmost&#x3D;min(topmost,dfsn[to]);

    if(topmost&#x3D;&#x3D;dfsn[node])
    &#123;
        ++sccnumber;
        while(true)
        &#123;
            int t&#x3D;s.top();
            s.pop();
            scc[t]&#x3D;sccnumber;
            group[sccnumber].push_back(t);
            if(t&#x3D;&#x3D;node) break;
        &#125;
    &#125;
    return topmost;
&#125;

void init(int n)
&#123;
    dfsnumber&#x3D;0,sccnumber&#x3D;0;
    for(int i&#x3D;1;i&lt;&#x3D;n;i++)
        graph[i].clear(),dag[i].clear(),dfsn[i]&#x3D;0,indegree[i]&#x3D;0,scc[i]&#x3D;0,group[i].clear();
&#125;

int main(void)
&#123;
    int tc;
    scanf(&quot;%d&quot;,&amp;tc);
    while(tc--)
    &#123;
        int n,m;
        scanf(&quot;%d %d&quot;, &amp;n,&amp;m);
        while(m--)
        &#123;
            int x,y;
            scanf(&quot;%d %d&quot;,&amp;x,&amp;y);
            graph[x].push_back(y);
        &#125;
        for(int i&#x3D;1;i&lt;&#x3D;n;i++)
            if(!dfsn[i]) SCC(i);

        &#x2F;&#x2F;이제 위상정렬이 가능해짐.
        for(int node&#x3D;1;node&lt;&#x3D;n;node++)
            for(int to:graph[node])
                if(scc[node]!&#x3D;scc[to])
                &#123;
                    dag[scc[node]].push_back(scc[to]);
                    indegree[scc[to]]++;
                &#125;

        int ans&#x3D;0;
        for(int i&#x3D;1;i&lt;&#x3D;sccnumber;i++)
            if (!indegree[i]) ans++;
        printf(&quot;%d\n&quot;,ans);
        init(n);
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="시간복잡도"><a href="#시간복잡도" class="headerlink" title="시간복잡도"></a>시간복잡도</h2><p>$O(V+E)$</p>
<blockquote>
<p>V : 노드 수, E : 간선 수</p>
</blockquote>
<h2 id="관련문제"><a href="#관련문제" class="headerlink" title="관련문제"></a>관련문제</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS80MTk2">백준4196 : 도미노<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>SCC</tag>
      </tags>
  </entry>
  <entry>
    <title>topological-sort</title>
    <url>/2021/01/24/2021-01-24-topological-sort/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="위상-정렬"><a href="#위상-정렬" class="headerlink" title="위상 정렬"></a>위상 정렬</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;

&#x2F;&#x2F;간선 추가할때 indegree 관리.
vector&lt;int&gt; dag[32001];
int indegree[32001];
&#x2F;&#x2F;n은 정점 수.
void topological_sort(int n)
&#123;
    vector&lt;int&gt; ans;&#x2F;&#x2F;위상정렬된 정점.
    queue&lt;int&gt; q;
    for(int i&#x3D;1;i&lt;&#x3D;n;i++)
        if(!indegree[i])
            q.push(i);
    while(!q.empty())
    &#123;
        int t&#x3D;q.front();
        q.pop();
        for(int go:dag[t])
            if(--indegree[go]&#x3D;&#x3D;0)
                q.push(go);
        ans.push_back(t);
    &#125;
    for(int i:ans)
        printf(&quot;%d &quot;,i); &#x2F;&#x2F;출력.
&#125;

int main()
&#123;
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    while(m--)
    &#123;
        int a,b;
        scanf(&quot;%d %d&quot;,&amp;a,&amp;b);
        dag[a].push_back(b);
        indegree[b]++;
    &#125;
    topological_sort(n);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="시간복잡도"><a href="#시간복잡도" class="headerlink" title="시간복잡도"></a>시간복잡도</h2><p>$O(V+E)$</p>
<blockquote>
<p>V : 정점 수, E : 간선 수</p>
</blockquote>
<h2 id="관련문제"><a href="#관련문제" class="headerlink" title="관련문제"></a>관련문제</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8yMjUy">백준2252 : 줄 세우기<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>topological-sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Fenwick-tree (binary indexed tree)</title>
    <url>/2021/01/31/2021-01-31-Fenwick-tree%20(binary%20indexed%20tree)/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="펜윅-트리"><a href="#펜윅-트리" class="headerlink" title="펜윅 트리"></a>펜윅 트리</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
#define ll long long
using namespace std;
&#x2F;&#x2F;크기는 n&#x3D;sz.
const int sz&#x3D;1000000;
ll BIT[sz+1];
ll arr[sz+1];

&#x2F;&#x2F;sum(i) : 1번째~i번째 수의 총합
ll sum(int i)
&#123;
    ll ret&#x3D;0;
    while(i&gt;0)
    &#123;
        ret+&#x3D;BIT[i];
        i-&#x3D;i&amp;-i;
    &#125;
    return ret;
&#125;

void update(int i, ll diff)
&#123;
    while(i&lt;&#x3D;sz)
    &#123;
        BIT[i]+&#x3D;diff;
        i+&#x3D;i&amp;-i;
    &#125;
&#125;

int main(void)
&#123;
    int n,m,k;
    scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;k);

    for(int i&#x3D;1;i&lt;&#x3D;n;i++)
    &#123;
        scanf(&quot;%lld&quot;,&amp;arr[i]);
        update(i,arr[i]);
    &#125;

    int q&#x3D;m+k;
    while(q--)
    &#123;
        int a; scanf(&quot;%d&quot;,&amp;a);
        if(a&#x3D;&#x3D;1)
        &#123;
            int b;ll c; scanf(&quot;%d %lld&quot;,&amp;b,&amp;c);
            update(b,c-arr[b]);
            arr[b]&#x3D;c;
        &#125;
        else
        &#123;
            int l,r; scanf(&quot;%d %d&quot;,&amp;l,&amp;r);
            printf(&quot;%lld\n&quot;,sum(r)-sum(l-1));
        &#125;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="시간복잡도"><a href="#시간복잡도" class="headerlink" title="시간복잡도"></a>시간복잡도</h2><ul>
<li>전처리 : $O(NlogN)$</li>
<li>구간 합 구하기 : $O(logN)$</li>
<li>값 업데이트 : $O(logN)$</li>
</ul>
<blockquote>
<p>N : 수의 개수</p>
</blockquote>
<h2 id="관련문제"><a href="#관련문제" class="headerlink" title="관련문제"></a>관련문제</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8yMDQy">백준2042 : 구간 합 구하기<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>data structure</category>
      </categories>
      <tags>
        <tag>Fenwick-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>segment-tree</title>
    <url>/2021/01/31/2021-01-31-segment-tree/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="세그먼트-트리"><a href="#세그먼트-트리" class="headerlink" title="세그먼트 트리"></a>세그먼트 트리</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
typedef long long ll;
&#x2F;&#x2F;크기는 n&lt;sz 이면서 sz&#x3D;1&lt;&lt;k 꼴로. 2^17&#x3D;131072 &#x2F; 2^18&#x3D;262144 &#x2F; 2^19&#x3D;524288 &#x2F; 2^20&#x3D;1048576
&#x2F;&#x2F;고쳐야 할 부분 (1)~(5)
const int sz&#x3D;1&lt;&lt;20;
ll arr[sz*2];

&#x2F;&#x2F;처음 값 입력받은 후 트리 구축.
void construct()&#123;
    for(int i&#x3D;sz-1;i&gt;&#x3D;1;i--)
        arr[i]&#x3D;arr[i*2]+arr[i*2+1];&#x2F;&#x2F;(1)
&#125;

void update(int i,ll val)&#123;
    i+&#x3D;sz,arr[i]&#x3D;val;
    while(i&gt;1)i&#x2F;&#x3D;2,arr[i]&#x3D;arr[i*2]+arr[i*2+1];&#x2F;&#x2F;(2)
&#125;

ll query(int s,int e,int node,int ns,int ne)&#123;
    if(e&lt;ns||ne&lt;s)return 0;&#x2F;&#x2F;(3)
    if(s&lt;&#x3D;ns&amp;&amp;ne&lt;&#x3D;e)return arr[node];&#x2F;&#x2F;(4)
    int mid&#x3D;(ns+ne)&#x2F;2;
    return query(s,e,node*2,ns,mid)+query(s,e,node*2+1,mid+1,ne);&#x2F;&#x2F;(5)
&#125;

int main()&#123;
    int n,m,k;
    scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;k);

    &#x2F;&#x2F;값 입력받는 위치 주의.(+sz)
    for(int i&#x3D;1;i&lt;&#x3D;n;i++)
        scanf(&quot;%lld&quot;,&amp;arr[i+sz]);
    construct();

    int q&#x3D;m+k;
    while(q--)&#123;
        int a; scanf(&quot;%d&quot;,&amp;a);
        if(a&#x3D;&#x3D;1)&#123;
            int b;ll c; scanf(&quot;%d %lld&quot;,&amp;b,&amp;c);
            update(b,c);
        &#125;
        else&#123;
            int l,r; scanf(&quot;%d %d&quot;,&amp;l, &amp;r);
            printf(&quot;%lld\n&quot;, query(l,r,1,0,sz-1));
        &#125;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="시간복잡도"><a href="#시간복잡도" class="headerlink" title="시간복잡도"></a>시간복잡도</h2><ul>
<li>전처리 : $O(N)$</li>
<li>구간 합 구하기 : $O(logN)$</li>
<li>값 업데이트 : $O(logN)$</li>
</ul>
<blockquote>
<p>N : 수의 개수</p>
</blockquote>
<h2 id="관련문제"><a href="#관련문제" class="headerlink" title="관련문제"></a>관련문제</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8yMDQy">백준2042 : 구간 합 구하기<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>data structure</category>
      </categories>
      <tags>
        <tag>segment-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>prime-factorization</title>
    <url>/2021/02/03/2021-02-03-prime-factorization/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="에라토스테네스의-체"><a href="#에라토스테네스의-체" class="headerlink" title="에라토스테네스의 체"></a>에라토스테네스의 체</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
&#x2F;&#x2F;n&lt;&#x3D;sz^2이 되도록 sz 적당히 크게 잡기.
&#x2F;&#x2F;고쳐야 할 부분 (1)~(2)
const int sz&#x3D;3163;&#x2F;&#x2F;(1)
bool no_prime[sz+1]&#x3D;&#123;true,true&#125;;
vector&lt;int&gt; prime;

int main()
&#123;
    int n; scanf(&quot;%d&quot;,&amp;n);
    
    for(int i&#x3D;2;i*i&lt;&#x3D;n;i++)&#x2F;&#x2F;(2)
        if(!no_prime[i])
        &#123;
            prime.push_back(i);
            for(int j&#x3D;i*2;j&lt;&#x3D;sz;j+&#x3D;i)
                no_prime[j]&#x3D;true;
        &#125;

    for(int i:prime)
        while(n%i&#x3D;&#x3D;0)
        &#123;
            printf(&quot;%d\n&quot;,i);
            n&#x2F;&#x3D;i;
        &#125;
    &#x2F;&#x2F;prime 벡터에 없는 큰 소수가 남았다면 직접 출력.
    if(n!&#x3D;1) printf(&quot;%d&quot;,n);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="시간복잡도"><a href="#시간복잡도" class="headerlink" title="시간복잡도"></a>시간복잡도</h2><ul>
<li>전처리 : $O(\sqrt{N}log\sqrt{N})$</li>
<li>소인수분해 : $O(\sqrt{N}) (&#x3D;O(\sqrt{N}+logN))$</li>
</ul>
<blockquote>
<p>N : 소인수분해 할 가장 큰 수.</p>
</blockquote>
<h2 id="관련문제"><a href="#관련문제" class="headerlink" title="관련문제"></a>관련문제</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8xMTY1Mw==">백준11653 : 소인수분해<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="언더-프라임"><a href="#언더-프라임" class="headerlink" title="언더 프라임"></a>언더 프라임</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
&#x2F;&#x2F;n&lt;&#x3D;sz이 되도록. n은 소인수분해 할 가장 큰 수.
const int sz&#x3D;5000000;
int under_prime[sz+1];&#x2F;&#x2F;under_prime[i] : i을 나누는 가장 작은 소수.

void logsieve()
&#123;
    under_prime[1]&#x3D;1;
    &#x2F;&#x2F;1+(1&#x2F;2)+(1&#x2F;3)+...+(1&#x2F;sz) 는 log sz로 수렴.
    for(int i&#x3D;2;i&lt;&#x3D;sz;i++)
        if(!under_prime[i])
            for(int j&#x3D;i;j&lt;&#x3D;sz;j+&#x3D;i)
                if(!under_prime[j])
                    under_prime[j]&#x3D;i;
&#125;

int main()
&#123;
    &#x2F;&#x2F;메인에서 함수 실행하기.
    logsieve();
    int n; scanf(&quot;%d&quot;,&amp;n);
    while(n--)
    &#123;
        int k; scanf(&quot;%d&quot;,&amp;k);
        vector&lt;int&gt; factor;
        while(k&gt;1)
        &#123;
            factor.push_back(under_prime[k]);
            k&#x2F;&#x3D;under_prime[k];
        &#125;
        for(int i:factor)
            printf(&quot;%d &quot;,i);
        printf(&quot;\n&quot;);
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="시간복잡도-1"><a href="#시간복잡도-1" class="headerlink" title="시간복잡도"></a>시간복잡도</h2><ul>
<li>전처리 : $O(NlogN)$</li>
<li>소인수분해 : $O(logN)$</li>
</ul>
<blockquote>
<p>N : 소인수분해 할 가장 큰 수.</p>
</blockquote>
<h2 id="관련문제-1"><a href="#관련문제-1" class="headerlink" title="관련문제"></a>관련문제</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8xNjU2Mw==">백준16563 : 어려운 소인수분해<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>prime-factorization</tag>
        <tag>sieve-of-Eratosthenes</tag>
        <tag>under-prime</tag>
      </tags>
  </entry>
  <entry>
    <title>freopen</title>
    <url>/2021/02/12/2021-02-12-freopen/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="Clion에서-파일-입출력-하기"><a href="#Clion에서-파일-입출력-하기" class="headerlink" title="Clion에서 파일 입출력 하기"></a>Clion에서 파일 입출력 하기</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;

int main()
&#123;
    int num,sum&#x3D;0;
    char buff[10000];buff[0]&#x3D;0;

    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);&#x2F;&#x2F;&quot;in.txt&quot;의 데이터를 &quot;r&quot;(read). &quot;in.txt&quot;는 &quot;main.cpp&quot;와 같은 경로에 있어야함.
    while(scanf(&quot;%d&quot;,&amp;num)!&#x3D;EOF)
        sum+&#x3D;num;

    printf(&quot;%d&quot;,sum);&#x2F;&#x2F;freopen 이전의 출력은 console 창에 출력됨.

    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);&#x2F;&#x2F;&quot;out.txt&quot;에 데이터를 &quot;w&quot;(write).
    printf(&quot;%d\n&quot;,sum);&#x2F;&#x2F;freopen 이후의 출력은 &quot;out.txt&quot;에 기록됨.

    freopen(&quot;in2.txt&quot;,&quot;r&quot;,stdin);

    freopen(&quot;out.txt&quot;,&quot;a&quot;,stdout);&#x2F;&#x2F;이미 존재하는 파일의 끝에서 read 목적으로 파일을 엶.
    while(scanf(&quot;%[^\n]&quot;,buff)!&#x3D;EOF)&#x2F;&#x2F;띄어쓰기를 포함하여 한줄씩 출력.
        printf(&quot;%s\n&quot;,buff),buff[0]&#x3D;0,getchar();

    fclose(stdin),fclose(stdout);
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="설정"><a href="#설정" class="headerlink" title="설정"></a>설정</h2><ol>
<li><p>우측 상단의 <code>Debug</code> - <code>Edit Configurations</code> 클릭</p>
<p>![Edit Configurations](\source\images\2021-02-12\Edit Configurations.JPG)</p>
</li>
<li><p><code>Working directory</code> 를 <code>main.cpp</code> 이 있는 위치로 바꿔줍니다. </p>
<p>![Working directory](\source\images\2021-02-12\Working directory.JPG)</p>
</li>
<li><p>해당 위치에 사용할 input data (<code>in.txt</code>, <code>in2.txt</code>) 를 넣어줍니다.</p>
<p><img src="/%5Csource%5Cimages%5C2021-02-12%5Cmain.cpp.JPG" alt="main.cpp"></p>
</li>
</ol>
<h2 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h2><h3 id="in-txt"><a href="#in-txt" class="headerlink" title="in.txt"></a>in.txt</h3><pre class="line-numbers language-.txt" data-language=".txt"><code class="language-.txt">1 2 3 4 5 6 7 8 9 10<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="in2-txt"><a href="#in2-txt" class="headerlink" title="in2.txt"></a>in2.txt</h3><pre class="line-numbers language-.txt" data-language=".txt"><code class="language-.txt">
#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
#define ll long long
#define MOD (ll)1000000007
#define pii pair&lt;int,int&gt;
#define pll pair&lt;ll,ll&gt;
#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());
ll GCD(ll a,ll b)&#123;return b?GCD(b,a%b):a;&#125;
ll power(ll a,ll b)&#123;ll ret&#x3D;1;while(b)&#123;if(b%2)ret&#x3D;ret*a%MOD;a&#x3D;a*a%MOD;b&#x2F;&#x3D;2;&#125;return ret;&#125;
const int sz &#x3D; 1&lt;&lt;17;

int a[100001];

int main()
&#123;
    int tc;
    scanf(&quot;%d&quot;,&amp;tc);
    while(tc--)
    &#123;
        int n;
        scanf(&quot;%d&quot;,&amp;n);
        for(int i&#x3D;1;i&lt;&#x3D;n;i++)
        &#123;
            scanf(&quot;%d&quot;,&amp;a[i]);
        &#125;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="console"><a href="#console" class="headerlink" title="console"></a>console</h3><p><img src="/%5Csource%5Cimages%5C2021-02-12%5Cconsole.JPG" alt="console"></p>
<h3 id="out-txt"><a href="#out-txt" class="headerlink" title="out.txt"></a>out.txt</h3><pre class="line-numbers language-.txt" data-language=".txt"><code class="language-.txt">55

#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
#define ll long long
#define MOD (ll)1000000007
#define pii pair&lt;int,int&gt;
#define pll pair&lt;ll,ll&gt;
#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());
ll GCD(ll a,ll b)&#123;return b?GCD(b,a%b):a;&#125;
ll power(ll a,ll b)&#123;ll ret&#x3D;1;while(b)&#123;if(b%2)ret&#x3D;ret*a%MOD;a&#x3D;a*a%MOD;b&#x2F;&#x3D;2;&#125;return ret;&#125;
const int sz &#x3D; 1&lt;&lt;17;

int a[100001];

int main()
&#123;
    int tc;
    scanf(&quot;%d&quot;,&amp;tc);
    while(tc--)
    &#123;
        int n;
        scanf(&quot;%d&quot;,&amp;n);
        for(int i&#x3D;1;i&lt;&#x3D;n;i++)
        &#123;
            scanf(&quot;%d&quot;,&amp;a[i]);
        &#125;
    &#125;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>out.txt</code> 은 여기에 생성됩니다.</p>
<p><img src="/%5Csource%5Cimages%5C2021-02-12%5Cout.JPG" alt="out"></p>
]]></content>
      <categories>
        <category>PS</category>
      </categories>
      <tags>
        <tag>freopen</tag>
      </tags>
  </entry>
  <entry>
    <title>segment-tree (with lazy propagation)</title>
    <url>/2021/01/31/2021-01-31-segment-tree%20(with%20lazy%20propagation)/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="세그먼트-트리-구간-업데이트"><a href="#세그먼트-트리-구간-업데이트" class="headerlink" title="세그먼트 트리 (구간 업데이트)"></a>세그먼트 트리 (구간 업데이트)</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
#define ll long long
using namespace std;
&#x2F;&#x2F;크기는 n&lt;sz 이면서 sz&#x3D;1&lt;&lt;k 꼴로. 2^17&#x3D;131072 &#x2F; 2^18&#x3D;262144 &#x2F; 2^19&#x3D;524288 &#x2F; 2^20&#x3D;1048576
&#x2F;&#x2F;고쳐야 할 부분 (1)~(11)
const int sz &#x3D; 1&lt;&lt;20;
ll arr[sz*2], lazy[sz*2];

&#x2F;&#x2F;처음 값 입력받은 후 트리 구축.
void construct()
&#123;
    for(int i&#x3D;sz-1;i&gt;&#x3D;1;i--)
        arr[i]&#x3D;arr[i*2]+arr[i*2+1];&#x2F;&#x2F;(1)
&#125;

&#x2F;&#x2F;lazy 적용.
void propagate(int node,int ns,int ne)
&#123;
    if(!lazy[node]) return;&#x2F;&#x2F;(2)
    if(node&lt;sz)
    &#123;
        lazy[node*2]+&#x3D;lazy[node];&#x2F;&#x2F;(3)
        lazy[node*2+1]+&#x3D;lazy[node];&#x2F;&#x2F;(4)
    &#125;
    arr[node]+&#x3D;lazy[node]*(ll)(ne-ns+1);&#x2F;&#x2F;(5)
    lazy[node]&#x3D;0LL;&#x2F;&#x2F;(6)
&#125;

void update(int s,int e,ll k,int node,int ns,int ne)
&#123;
    propagate(node,ns,ne);
    if(e&lt;ns||ne&lt;s)return;
    if (s&lt;&#x3D;ns&amp;&amp;ne&lt;&#x3D;e)
    &#123;
        lazy[node]+&#x3D;k;&#x2F;&#x2F;(7)
        propagate(node,ns,ne); return;
    &#125;
    int mid&#x3D;(ns+ne)&#x2F;2;
    update(s,e,k,node*2,ns,mid),update(s,e,k,node*2+1,mid+1,ne);
    arr[node]&#x3D;arr[node*2]+arr[node*2+1];&#x2F;&#x2F;(8)
&#125;

ll query(int s,int e,int node,int ns,int ne)
&#123;
    propagate(node,ns,ne);
    if(e&lt;ns||ne&lt;s)return 0;&#x2F;&#x2F;(9)
    if(s&lt;&#x3D;ns&amp;&amp;ne&lt;&#x3D;e)return arr[node];&#x2F;&#x2F;(10)
    int mid&#x3D;(ns+ne)&#x2F;2;
    return query(s,e,node*2,ns,mid)+query(s,e,node*2+1,mid+1,ne);&#x2F;&#x2F;(11)
&#125;

int main(void)
&#123;
    int n,m,k;
    scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;k);

    &#x2F;&#x2F;값 입력받는 위치 주의.(+sz)
    for(int i&#x3D;1;i&lt;&#x3D;n;i++)
        scanf(&quot;%lld&quot;,&amp;arr[i+sz]);
    construct();

    int q&#x3D;m+k;
    while(q--)
    &#123;
        int a; scanf(&quot;%d&quot;,&amp;a);
        if(a&#x3D;&#x3D;1)
        &#123;
            int l,r;ll d; scanf(&quot;%d %d %lld&quot;,&amp;l,&amp;r,&amp;d);
            update(l,r,d,1,0,sz-1);
        &#125;
        else
        &#123;
            int l,r; scanf(&quot;%d %d&quot;,&amp;l,&amp;r);
            printf(&quot;%lld\n&quot;, query(l,r,1,0,sz-1));
        &#125;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="시간복잡도"><a href="#시간복잡도" class="headerlink" title="시간복잡도"></a>시간복잡도</h2><ul>
<li>전처리 : $O(N)$</li>
<li>구간 합 구하기 : $O(logN)$</li>
<li>값 업데이트 : $O(logN)$</li>
</ul>
<blockquote>
<p>N : 수의 개수</p>
</blockquote>
<h2 id="관련문제"><a href="#관련문제" class="headerlink" title="관련문제"></a>관련문제</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8xMDk5OQ==">백준10999 : 구간 합 구하기 2<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>data structure</category>
      </categories>
      <tags>
        <tag>segment-tree (with lazy propagation)</tag>
      </tags>
  </entry>
  <entry>
    <title>interactive problem</title>
    <url>/2021/02/14/2021-02-14-interactive%20problem/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h1><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9wcm9ibGVtc2V0L3Byb2JsZW0vMTQyNS9G">Codeforces 1425F - Flamingoes of Mystery<i class="fa fa-external-link-alt"></i></span></p>
<ol>
<li>$N$ 개의 신비한 새장이 있고, $i$ 번째 새장에는 $A_i$ 마리의 플라밍고가 들어있습니다.</li>
<li>$?\ L\ R$ 의 형태로 질문을 하면, $L$ ~ $R$ 번째 새장에 들어있는 플라밍고의 마릿수 합을 알려줍니다.</li>
<li>최대 $N$ 번의 질문으로, 각 새장에 들어있는 플라밍고의 수를 알아내야 합니다.</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;

int sum[1001],ans[1001];

int main()
&#123;
    int n; scanf(&quot;%d&quot;,&amp;n);
    for(int i&#x3D;2;i&lt;&#x3D;n;i++)
    &#123;
        printf(&quot;? 1 %d\n&quot;,i);
        fflush(stdout);
        scanf(&quot;%d&quot;,&amp;sum[i]);
    &#125;

    printf(&quot;? 2 3\n&quot;);
    fflush(stdout);
    int tt; scanf(&quot;%d&quot;,&amp;tt);

    ans[1]&#x3D;sum[1]&#x3D;sum[3]-tt;
    for(int i&#x3D;2;i&lt;&#x3D;n;i++)
        ans[i]&#x3D;sum[i]-sum[i-1];

    printf(&quot;! &quot;);
    for(int i&#x3D;1;i&lt;&#x3D;n;i++)
        printf(&quot;%d &quot;,ans[i]);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">6

5

9

15

22

30

8
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
? 1 2

? 1 3

? 1 4

? 1 5

? 1 6

? 2 3

! 1 4 4 6 7 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>PS</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>interactive</tag>
      </tags>
  </entry>
  <entry>
    <title>bipartite matching</title>
    <url>/2021/02/23/2021-02-23-bipartite%20matching/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="이분-매칭"><a href="#이분-매칭" class="headerlink" title="이분 매칭"></a>이분 매칭</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;

&#x2F;&#x2F;a,b의 크기는 이분 그래프 각각의 정점 수. vis,graph의 크기는 a의 크기와 같게.
int a[1001],b[1001];
bool vis[1001];
vector&lt;int&gt; graph[1001];

bool BM(int cur)
&#123;
    vis[cur]&#x3D;true;
    for(int go:graph[cur])
        if(b[go]&#x3D;&#x3D;-1||!vis[b[go]]&amp;&amp;BM(b[go]))
        &#123;
            a[cur]&#x3D;go;
            b[go]&#x3D;cur;
            return true;
        &#125;
    return false;
&#125;

int main()
&#123;
    int n,m;scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    &#x2F;&#x2F;아직 매칭되기 전.(-1)
    fill(a+1,a+1+n,-1);
    fill(b+1,b+1+m,-1);

    for(int i&#x3D;1;i&lt;&#x3D;n;i++)
    &#123;
        int work,t;scanf(&quot;%d&quot;,&amp;work);
        while(work--)
        &#123;
            scanf(&quot;%d&quot;,&amp;t);
            graph[i].push_back(t);
        &#125;
    &#125;

    int ans&#x3D;0;
    for(int i&#x3D;1;i&lt;&#x3D;n;i++)
    &#123;
        fill(vis+1,vis+1+n,false);
        if(BM(i)) ans++;&#x2F;&#x2F;새로운 매칭에 성공.
    &#125;
    printf(&quot;%d&quot;,ans);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="시간복잡도"><a href="#시간복잡도" class="headerlink" title="시간복잡도"></a>시간복잡도</h2><p>$O(VE)$</p>
<blockquote>
<p>V : 정점 수, E : 간선 수</p>
</blockquote>
<h2 id="관련문제"><a href="#관련문제" class="headerlink" title="관련문제"></a>관련문제</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8xMTM3NQ==">백준11375 : 열혈강호<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>bipartite matching</tag>
      </tags>
  </entry>
  <entry>
    <title>network flow</title>
    <url>/2021/03/08/2021-03-08-network%20flow/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="최대-유량"><a href="#최대-유량" class="headerlink" title="최대 유량"></a>최대 유량</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;

&#x2F;&#x2F;크기는 모든 정점 개수의 합+1 (소스 S&#x3D;0,싱크 E&#x3D;n+m+1)
int cap[402][402], flow[402][402];
vector&lt;int&gt; graph[402];

int main()
&#123;
    int n,m;scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    int S&#x3D;0,E&#x3D;n+m+1;

    for(int i&#x3D;1;i&lt;&#x3D;n;i++)
    &#123;
        int q,s;scanf(&quot;%d&quot;,&amp;q);
        while(q--)
        &#123;
            scanf(&quot;%d&quot;,&amp;s);
            cap[i][s+n]&#x3D;1;
            graph[i].push_back(s+n);
            graph[s+n].push_back(i);
        &#125;
    &#125;

    &#x2F;&#x2F;각 번호당 소는 한 마리임.(소스-&gt;)
    for(int i&#x3D;1;i&lt;&#x3D;n;i++)
    &#123;
        cap[S][i]&#x3D;1;
        graph[S].push_back(i);
        graph[i].push_back(S);
    &#125;

    &#x2F;&#x2F;축사 한 칸에는 최대 한 마리의 소만 들어감.(-&gt;싱크)
    for(int i&#x3D;n+1;i&lt;&#x3D;m+n;i++)
    &#123;
        cap[i][E]&#x3D;1;
        graph[i].push_back(E);
        graph[E].push_back(i);
    &#125;

    int ans&#x3D;0;
    &#x2F;&#x2F;Edmonds-Karp 알고리즘.
    while(true)
    &#123;
        vector&lt;int&gt;prev(402,-1);
        queue&lt;int&gt; q; q.push(S);
        while(!q.empty()&amp;&amp;prev[E]&#x3D;&#x3D;-1)
        &#123;
            int cur&#x3D;q.front();q.pop();
            for(int go:graph[cur])
                if(cap[cur][go]-flow[cur][go]&gt;0&amp;&amp;prev[go]&#x3D;&#x3D;-1)
                &#123;
                    prev[go]&#x3D;cur, q.push(go);
                    if(go&#x3D;&#x3D;E) break;
                &#125;
        &#125;
        if(prev[E]&#x3D;&#x3D;-1) break;
        int mn&#x3D;1e9, cur&#x3D;E;
        while(cur!&#x3D;S)
        &#123;
            mn&#x3D;min(mn,cap[prev[cur]][cur]-flow[prev[cur]][cur]);
            cur&#x3D;prev[cur];
        &#125;
        cur&#x3D;E;
        while(cur!&#x3D;S)
        &#123;
            flow[prev[cur]][cur]+&#x3D;mn;
            flow[cur][prev[cur]]-&#x3D;mn;
            cur&#x3D;prev[cur];
        &#125;
        ans+&#x3D;mn;
    &#125;
    printf(&quot;%d&quot;,ans);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="시간복잡도"><a href="#시간복잡도" class="headerlink" title="시간복잡도"></a>시간복잡도</h2><p>$min(O(E^{2}V),O(EF)) \approx O(E^{2}V)$</p>
<blockquote>
<p>V : 정점 수, E : 간선 수, F : 답으로 출력하는 수</p>
</blockquote>
<h2 id="관련문제"><a href="#관련문제" class="headerlink" title="관련문제"></a>관련문제</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8yMTg4">백준2188 : 축사 배정<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>network flow</tag>
      </tags>
  </entry>
</search>
